<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于docker+grafana+influxdb的性能监控系统搭建</title>
    <url>/posts/59d444a5.html</url>
    <content><![CDATA[<p>之前压测一直用的是jmeter自带的聚合报告来分析结果，但是对tps,qps等性能指标进行页面可视化显示效果不是很好，so，引入了grafana+influxdb，会有一个非常炫酷的可视化页面和全面的视图分析。</p>
<p>在搭建之前，先简单了解下grafana和influxdb是什么。</p>
<h2 id="influxdb简介"><a href="#influxdb简介" class="headerlink" title="influxdb简介"></a>influxdb简介</h2><p><a href="https://github.com/influxdata/influxdb">Influx DB</a>是一个开源时间序列数据库。那么问题来了，什么叫时序数据库？想详细了解可以查看这篇<a href="https://www.sohu.com/a/237660940_130419">文章</a>。</p>
<p><strong>influxdb有三个特性</strong>：</p>
<ol>
<li>Time Series （时间序列）：可以使用与时间有关的相关聚合函数</li>
<li>Metrics（度量）：可以实时对大量数据进行计算</li>
<li>Eevents（事件）：它支持任意的事件数据</li>
</ol>
<p><strong>它的核心概念</strong>（以mysql作为参照）：</p>
<ol>
<li>database相当于mysql中的database</li>
<li>measurement相当于mysql中的表</li>
<li>point相当于mysql中的行</li>
<li>tag相当于mysql中的索引，只支持字符串类型</li>
<li>field相当于mysql中的列，支持多种类型</li>
<li>retention policy保存策略，这是influxdb特有的属性，rp指定数据在influxdb中的保存时间，时间已过，influxdb会自动清除数据。influxdb不支持修改语句，虽然有删除语句，但是不建议使用</li>
<li>continuous queries 特色功能之一，相当于定时任务。</li>
</ol>
<p><strong>一些基本语法</strong>（其实和mysql差不多，注意table是measurement）：</p>
<ol>
<li>create database “db_name” #创建数据库 </li>
<li>show databases #显示所有的数据库 </li>
<li>drop database “db_name” #删除数据库 </li>
<li>use db_name #使用数据库 </li>
<li>show measurements #显示该数据库中所有的表 </li>
<li>insert test,host=127.0.0.1,monitor_name=test count=1 #创建表，直接在插入数据的时候指定表名 </li>
<li>drop measurement “measurement_name”  #删除表 </li>
<li>select * from access_list  #查询access_list表</li>
</ol>
<p><strong><em>它具有的以上特点让其与数据实时监控形成完美契合。成为开发监控系统的首选数据库之一。</em></strong></p>
<h2 id="grafana简介"><a href="#grafana简介" class="headerlink" title="grafana简介"></a>grafana简介</h2><p><a href="https://github.com/grafana/grafana">grafana</a>是一款采用 go 语言编写的开源应用，主要用于大规模指标数据的可视化展现，是网络架构和应用分析中最流行的<strong>时序数据展示</strong>工具，目前已经支持绝大部分常用的时序数据库。</p>
<ol>
<li>面板：包含图形、singlestat 、表、热图、提醒清单，文本、仪表板列表</li>
<li>仪表板功能：变量（variables）、注释（animation）、文件夹、播放列表、搜索、分享、时间范围、进出口、脚本仪表板，JSON模型等</li>
<li>数据源：Graphite、Promthus、influxDB、mysql等</li>
<li>警报：引擎规则、度量、通知</li>
</ol>
<p>更多页面详细介绍，可以查看<a href="https://grafana.com/docs/grafana/latest/getting-started">官方文档</a>。</p>
<p>话不多说，下面我们开始部署~</p>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p>我们采用方便快速的docker进行部署。</p>
<h3 id="docker分别拉取grafana和influxdb镜像"><a href="#docker分别拉取grafana和influxdb镜像" class="headerlink" title="docker分别拉取grafana和influxdb镜像"></a>docker分别拉取grafana和influxdb镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull influxdb:1.7.10</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull grafana:6.6.2</span><br></pre></td></tr></table></figure>

<h3 id="创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信"><a href="#创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信" class="headerlink" title="创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信"></a>创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network create grafana</span><br></pre></td></tr></table></figure>

<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name=influxdb --network grafana -p 8086:8086 -v   <span class="variable">$&#123;PWD&#125;</span>/influxdb/:/var/liv/influxdb/ influxdb:1.7.10</span><br></pre></td></tr></table></figure>

<p><code>$&#123;PWD&#125;/influxdb/:/var/liv/influxdb/</code>将容器里/var/liv/influxdb/目录下挂载到宿主机的${PWD}/influxdb/的目录下</p>
<h3 id="进入influxdb容器内，创建一个数据库"><a href="#进入influxdb容器内，创建一个数据库" class="headerlink" title="进入influxdb容器内，创建一个数据库"></a>进入influxdb容器内，创建一个数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it influxdb influx</span><br><span class="line"><span class="comment"># 进入容器后，创建一个名为jmeter的数据库</span></span><br><span class="line">create database jmeter;</span><br></pre></td></tr></table></figure>

<h3 id="查看两个容器已经启动"><a href="#查看两个容器已经启动" class="headerlink" title="查看两个容器已经启动"></a>查看两个容器已经启动</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145515315.png"></p>
<h3 id="登录grafana网站进行配置-默认账号密码为admin-admin"><a href="#登录grafana网站进行配置-默认账号密码为admin-admin" class="headerlink" title="登录grafana网站进行配置(默认账号密码为admin,admin)"></a>登录grafana网站进行配置(默认账号密码为admin,admin)</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104727119.png"></p>
<h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104813179.png"></p>
<p><strong><em>jmeter支持两种:graphite和influxdb</em></strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104934731.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105006045.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105025396.png"></p>
<p><strong><em>数据同步时间5秒，jmeter隔5秒写入数据到db中，这里设置grafana间隔5秒读取db中的数据。</em></strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105038733.png"></p>
<h3 id="面板配置"><a href="#面板配置" class="headerlink" title="面板配置"></a>面板配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145131270.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145204904.png"></p>
<p><strong><em>导入jmeter的面板地址： <a href="https://grafana.com/grafana/dashboards/5496">https://grafana.com/grafana/dashboards/5496</a></em></strong></p>
<p><strong><em>也可以下载后导入json文件。</em></strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105457833.png"></p>
<h3 id="jmeter配置"><a href="#jmeter配置" class="headerlink" title="jmeter配置"></a>jmeter配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105610185.png"></p>
<h3 id="配置完成，发起接口请求即可在grafana实时显示接口相关图表"><a href="#配置完成，发起接口请求即可在grafana实时显示接口相关图表" class="headerlink" title="配置完成，发起接口请求即可在grafana实时显示接口相关图表"></a>配置完成，发起接口请求即可在grafana实时显示接口相关图表</h3><h2 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h2><p>最后，我们来捋一捋，从jmeter开始发起请求到最后在grafana上的数据展示，响应数据是如何进行流转的。</p>
<h3 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h3><p>jmeter使用命令行发起接口请求后，会产生一个**.jtl**的文件，里面记录着每个请求的一些线程数、响应码、响应时间等信息。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825112742837.png"></p>
<h3 id="influxdb"><a href="#influxdb" class="headerlink" title="influxdb"></a>influxdb</h3><p>在jmeter中添加了后端监听器，并选择了通过inlufxdb实现后端监听，因此，步骤1中的响应数据，会写入到influxdb的数据库中。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113234453.png"></p>
<p>进入influxdb容器内，查看数据</p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113841230.png"></p>
<p>使用<code>select * from jmeter</code>查看数据</p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113901681.png"></p>
<p>记录了每个请求的详细响应信息。</p>
<h3 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h3><p>由于我们配置的数据源是influxdb，因此面板展示的所有数据其实都是从influxdb的<strong>jmeter</strong>这个数据库中拿的。</p>
<p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105006045.png"></p>
<p><strong>so，整个数据流转，即jmeter产生jtl—&gt;存储到influxdb—&gt;grafana从influxdb拿数据。</strong></p>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>grafana</tag>
        <tag>influxdb</tag>
      </tags>
  </entry>
  <entry>
    <title>pytest-fixture使用总结</title>
    <url>/posts/9752a16f.html</url>
    <content><![CDATA[<h2 id="前言：测试前后的准备清理工作"><a href="#前言：测试前后的准备清理工作" class="headerlink" title="前言：测试前后的准备清理工作"></a>前言：测试前后的准备清理工作</h2><p>通常在测试过程中，都会包括三个步骤：测试前的准备(前置条件)-执行测试-测试后的清理。</p>
<p>在unittest框架中，通常使用setup/teardown来完成测试的前置和后置操作。</p>
<p>在pytest框架中，也有类似的方法来完成对应的操作，如使用 setup_method、setup_class、setup_module 来分别完成测试类方法、测试类，以及测试 module 的 setup；；使用 teardown_method、teardown_class、teardown_module 来分别完成测试类方法、测试类，以及测试 module 清理操作。</p>
<p>但是这种方式存在缺陷。 例如，在同一个测试类中，存在多个测试方法，假设每一个测试方法需要不同的 setup 或者 teardown 函数，此时该怎么办呢？</p>
<p>又如，这些前后置操作，能放到一个统一模块去管理么？</p>
<p>答案是肯定的，pytest提供了一种更高级的功能，<strong>fixture装饰器</strong>。</p>
<p>fixture装饰器可以非常方便的自定义各种前置后置方法供测试用例使用，而且可以通过<strong>conftest.py</strong>文件进行共享，供其他函数、模块、类或者整个项目使用。</p>
<h2 id="1、fixture语法"><a href="#1、fixture语法" class="headerlink" title="1、fixture语法"></a>1、fixture语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fixture(scope=<span class="string">&quot;function&quot;</span>, params=<span class="literal">None</span>, autouse=<span class="literal">False</span>, ids=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>fixture提供了5个参数。</p>
<h3 id="scope：控制fixture的作用域"><a href="#scope：控制fixture的作用域" class="headerlink" title="scope：控制fixture的作用域"></a>scope：控制fixture的作用域</h3><p>scpoe有4个级别，分别是：</p>
<p>function:在每一个function或者类方法中都会调用（默认）。</p>
<p>class:在每一个类中只调用一次。</p>
<p>module:在每一个.py 文件调用一次。</p>
<p>session:一个session调用一次，如运行整个项目有100条用例，那么本次用例执行过程中只会调用一次。</p>
<h3 id="params：一个可选的参数列表"><a href="#params：一个可选的参数列表" class="headerlink" title="params：一个可选的参数列表"></a>params：一个可选的参数列表</h3><p>params 以可选的参数列表形式存在。在测试函数中使用时，可通过 request.param 接收设置的返回值（即 params 列表里的值）。params 中有多少元素，在测试时，引用此 fixture 的函数就会调用几次。</p>
<h3 id="autouse：是否自动执行设置的-fixtures"><a href="#autouse：是否自动执行设置的-fixtures" class="headerlink" title="autouse：是否自动执行设置的 fixtures"></a>autouse：是否自动执行设置的 fixtures</h3><p>当 autouse 为 True 时，测试函数即使不调用 fixture 装饰器，定义的 fixture 函数也会被执行。</p>
<h3 id="ids：指定每个字符串-id"><a href="#ids：指定每个字符串-id" class="headerlink" title="ids：指定每个字符串 id"></a>ids：指定每个字符串 id</h3><p>当有多个 params 时，针对每一个 param，可以指定 id，这个 id 将变为测试用例名字的一部分。如果没有提供 id，则 id 将自动生成。</p>
<h3 id="name：fixture-的名称"><a href="#name：fixture-的名称" class="headerlink" title="name：fixture 的名称"></a>name：fixture 的名称</h3><p>name 是 fixtures 的名称， 它默认是你装饰的那个 fixture 函数的名称。可以通过 name 参数来更改这个 fixture 名称，更改后，如果这个 fixture 被调用，则使用更改后的名称即可。</p>
<h2 id="2、fixture-用法"><a href="#2、fixture-用法" class="headerlink" title="2、fixture 用法"></a>2、fixture 用法</h2><h3 id="通过函数名直接使用"><a href="#通过函数名直接使用" class="headerlink" title="通过函数名直接使用"></a>通过函数名直接使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>将fixture的名字通过参数直接传入测试方法即可。运行用例后，<code>demo()</code>方法会先于<code>test_demo()</code>执行。</p>
<h3 id="通过usefixtures装饰器使用"><a href="#通过usefixtures装饰器使用" class="headerlink" title="通过usefixtures装饰器使用"></a>通过usefixtures装饰器使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.usefixtures(&#x27;demo&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.usefixtures(&#x27;demo&#x27;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这样写的话，<strong>fixture无法返回参数</strong>。</p>
<h3 id="多参数使用"><a href="#多参数使用" class="headerlink" title="多参数使用"></a>多参数使用</h3><p>由于fixture提供了<code>paramas</code>参数，因此fixture也可以实现参数化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(params=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture：<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PASSED                                             [ 33%]test</span><br><span class="line">调用fixture：b</span><br><span class="line">PASSED                                             [ 66%]test</span><br><span class="line">调用fixture：c</span><br><span class="line">PASSED                                             [100%]test</span><br></pre></td></tr></table></figure>

<p>可以看到，将会生成3条用例。</p>
<h3 id="autouse-参数隐式使用"><a href="#autouse-参数隐式使用" class="headerlink" title="autouse 参数隐式使用"></a>autouse 参数隐式使用</h3><p>以上方式实现了 fixtures 和测试函数的松耦合，但是仍然存在问题：每个测试函数都需要显式声明要用哪个 fixtures。</p>
<p>基于此，pytest 提供了<strong>autouse 参数</strong>，允许我们在不调用 fixture 装饰器的情况下使用定义的fixture。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(autouse=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">demo.py::test_demo 调用fixture</span><br><span class="line">PASSED                                                [100%]测试</span><br></pre></td></tr></table></figure>

<h3 id="多-fixture-笛卡尔积使用"><a href="#多-fixture-笛卡尔积使用" class="headerlink" title="多 fixture 笛卡尔积使用"></a>多 fixture 笛卡尔积使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(params=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix1</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fix1:<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(params=[1, 2])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix2</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fix2:<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix1, fix2</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>将会生成3*2=6条用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用fix1:a</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 16%]-----我是分割线------</span><br><span class="line">调用fix1:a</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [ 33%]-----我是分割线------</span><br><span class="line">调用fix1:b</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 50%]-----我是分割线------</span><br><span class="line">调用fix1:b</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [ 66%]-----我是分割线------</span><br><span class="line">调用fix1:c</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 83%]-----我是分割线------</span><br><span class="line">调用fix1:c</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [100%]-----我是分割线------</span><br></pre></td></tr></table></figure>

<h3 id="fixture间嵌套使用"><a href="#fixture间嵌套使用" class="headerlink" title="fixture间嵌套使用"></a>fixture间嵌套使用</h3><p>不同的fixture间也可以嵌套使用，将<code>fix1</code>作为参数传入<code>fix2</code>中，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;调用fix1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix2</span>(<span class="params">fix1</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;调用fix2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix2</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">demo.py::test_demo 调用fix1</span><br><span class="line">调用fix2</span><br><span class="line">PASSED                                                [100%]-----我是分割线------</span><br></pre></td></tr></table></figure>

<p>可以看到，当调用<code>fix2</code>时，会先调用fix1。</p>
<h3 id="使用-conftest-py-来共享-fixture"><a href="#使用-conftest-py-来共享-fixture" class="headerlink" title="使用 conftest.py 来共享 fixture"></a>使用 conftest.py 来共享 fixture</h3><p>日常工作测试中，我们常常需要在全局范围内使用同一个测试前置操作。例如，测试开始时首先进行登录操作，接着连接数据库。</p>
<p>这种情况下，我们就需要使用 <strong>conftest.py</strong>。在 conftest.py 中定义的 fixture 不需要进行 import，pytest 会自动查找使用。 pytest 查找 fixture 的顺序是首先查找测试类（Class），接着查找测试模块（Module），然后是 conftest.py 文件，最后是内置或者第三方插件。</p>
<h3 id="通过yield唤醒teardown"><a href="#通过yield唤醒teardown" class="headerlink" title="通过yield唤醒teardown"></a>通过yield唤醒teardown</h3><p>前面fixture已经帮我们实现了前置操作，那么后置如何实现呢？非常简单，通过关键字<strong>yield</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;我是前置条件&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">&#x27;我是后置条件&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">demo.py::test_demo 我是前置条件</span><br><span class="line">PASSED                                                [100%]-----我是分割线------</span><br><span class="line">我是后置条件</span><br></pre></td></tr></table></figure>

<p>通过yield，会讲该函数变为生成器，这里具体原理先不展开，简单来说，<strong>yield之前的前置条件，yield之后的为后置条件。</strong></p>
<h3 id="有返回值的fixture"><a href="#有返回值的fixture" class="headerlink" title="有返回值的fixture"></a>有返回值的fixture</h3><p>大部分情况下，我都会使用fixture来返回一些值来供测试用例使用，如登录的cookie、token、数据库的连接对象等，那么fixture的返回值又是如何传递给用例的呢？如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    <span class="comment"># 接收fix值传递给了变量x</span></span><br><span class="line">    x= fix</span><br><span class="line">    print(<span class="string">f&#x27;这是我接收到fix的变量：<span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当然，也可以是多个值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    c = <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a,b,c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    <span class="comment"># 接收fix值传递给了变量x,y,z</span></span><br><span class="line">    <span class="comment"># 如果只用一个变量接收，类型将会是元组</span></span><br><span class="line">    x,y,z = fix</span><br><span class="line">    print(<span class="string">f&#x27;这是我接收到fix的变量：<span class="subst">&#123;x&#125;</span><span class="subst">&#123;y&#125;</span><span class="subst">&#123;z&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>同理，<strong>yield</strong>也能返回值。</p>
<h3 id="pytest-mark-parametrize-和-pytest-fixture-结合使用"><a href="#pytest-mark-parametrize-和-pytest-fixture-结合使用" class="headerlink" title="pytest.mark.parametrize 和 pytest.fixture 结合使用"></a>pytest.mark.parametrize 和 pytest.fixture 结合使用</h3><p>现在有一个问题，如果fixture是做了参数化的，如何在用例中动态地给它传入参数呢？</p>
<p>在我日常工作中，会有这么一种场景：通常我会把数据库连接放到fixture中，但是不同case中用到的数据库可能不是同一个，这就导致我会根据不同的数据库配置信息，实例多个db连接对象，那么我该如何把不同的数据库配置信息，在用例层传入给fixture呢？总不可能每个数据库都创建一个fixture吧？来看看用fixture结合parametrize是如何优雅地实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope=&#x27;class&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_db</span>(<span class="params">request</span>):</span></span><br><span class="line">    db = HandleMysql(request.param)</span><br><span class="line">    <span class="keyword">yield</span> db</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span>:</span></span><br><span class="line">    <span class="comment"># db1,db2,db3是伪代码，表示数据库不同的连接配置信息</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(&#x27;connect_db&#x27;, [db_conf], indirect=True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">self,connect_db</span>):</span></span><br><span class="line">        <span class="comment"># 接收fix值传递给了变量x</span></span><br><span class="line">        db = connect_db</span><br><span class="line">        print(<span class="string">f&#x27;这是我的数据库连接对象：<span class="subst">&#123;connect_db&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>首先，fixture做了参数化，那么就需要在fixture中接受变量，传入<strong>request</strong>这个内置fixture，然后传入的变量，通过request的<strong>param</strong>接收，这是需要再fixture内部做的操作。</p>
<p>然后，在用例层的**@pytest.mark.parametrize**中，将配置信息变量<code>db_conf</code>传入到<code>connect_db</code>这个fixture中，需要注意的是，这里必须设置参数<code>indirect=True</code>。</p>
<blockquote>
<p>当indirect为True的时候，变量为固件函数名称的，执行的时候会将变量（此例中即为connect_db）当做函数来执行。</p>
<p>当indirect为false的时候，变量为固件函数名称的，执行的时候会将变量当做一个参数来执行。</p>
</blockquote>
<p>ok，日常项目中，关于fixture的使用就如上所述了。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>解决pymongo时区问题</title>
    <url>/posts/cd8f63bc.html</url>
    <content><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>最近在做接口自动化框架，其中有涉及到接口返回值与MongoDB中的数据校验，所以用到了pymongo这个库。在使用过程中，踩了一个大坑：当我根据日期去筛选数据的时候，发现接口返回的数据量和mongodb中记录的数据量始终不一致。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>先看三组数据（同一条数据）：</p>
<p>1.数据库连接工具Navicat中的记录</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: ObjectId(<span class="string">&quot;5f646902ee75270c044f15d2&quot;</span>),</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;TypeName&quot;</span>: <span class="string">&quot;运行&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;HappenTime&quot;</span>: ISODate(<span class="string">&quot;2020-03-18T07:55:03.605Z&quot;</span>),</span><br><span class="line">    <span class="attr">&quot;AppName&quot;</span>: <span class="string">&quot;vipservermailG1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;AppFriendlyName&quot;</span>: <span class="string">&quot;邮件服务&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.数据库连接工具MongoDB Compass中的记录</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>:<span class="string">&quot;5f646902ee75270c044f15d2&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;Version&quot;</span>:<span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;TypeName&quot;</span>:<span class="string">&quot;运行&quot;</span></span><br><span class="line">     <span class="string">&quot;HappenTime&quot;</span>:<span class="number">2020</span><span class="number">-03</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.605</span>,</span><br><span class="line">     <span class="attr">&quot;AppName&quot;</span>:<span class="string">&quot;vipservermailG1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;AppFriendlyName&quot;</span>:<span class="string">&quot;邮件服务&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.通过pymongo查出的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5f646902ee75270c044f15d2&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;Version&#x27;</span>: <span class="string">&#x27;1.0&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;TypeName&#x27;</span>: <span class="string">&#x27;运行&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;HappenTime&#x27;</span>: datetime.datetime(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">605000</span>), </span><br><span class="line">    <span class="string">&#x27;AppName&#x27;</span>: <span class="string">&#x27;vipservermailG1&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;AppFriendlyName&#x27;</span>: <span class="string">&#x27;邮件服务&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我发现同一条数据，在两个不同的数据库连接工具中日期”HappenTime”居然不一样，这个ISODate是什么鬼？查阅一番资料后才搞明白，原来mongo中的date类型以UTC（Coordinated Universal Time）存储，即格林尼治标准时间，而中国是在东八区，所以系统时间是加了时区的，即UTC+0800时间，<strong>两者正好相差8个小时</strong>。</p>
<blockquote>
<p>“2020-03-18T07:55:03.605Z”这种带T带Z的时间即为ISODate，它定义了互联网上日期/时间的偏移量表示。</p>
<p>同一时刻，不同时区的表示方法：</p>
<p>UTC时间：2020-03-18T07:55:03.605Z</p>
<p>CST时间（即东八区北京时间）：2020-03-18T07:55:03.605+08:00</p>
</blockquote>
<p>在接口查询数据库时，是以系统时间去查询的，然而从上面第三组数据可以看出，在pymongo去查询数据时，会将ISODate转化为Python的datetime.datetime对象，时间仍然是UTC时间，即没有加时区。所以才会出现两边数据不一致的情况。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在搞懂问题根本原因后，那么解决方法也就非常明确了，在查询数据库时需要加上时区，两边时间保证一致即可。</p>
<p>pymongo也提供了非常简便地加时区的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">tzinfo = pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment"># 时区</span></span><br><span class="line">client = pymongo.MongoClient(</span><br><span class="line">    host=<span class="string">&#x27;1.1.1.1&#x27;</span>, </span><br><span class="line">    port=<span class="number">10</span>, </span><br><span class="line">    username=<span class="string">&#x27;admin&#x27;</span>, </span><br><span class="line">    password=<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    tz_aware=<span class="literal">True</span>, <span class="comment"># 设置为True</span></span><br><span class="line">    tzinfo=tzinfo  <span class="comment"># 传入时区信息</span></span><br><span class="line">)</span><br><span class="line">db = client[<span class="string">&#x27;log&#x27;</span>]</span><br><span class="line">collection = db[<span class="string">&#x27;systemruning&#x27;</span>]</span><br><span class="line">data = collection.find(&#123;<span class="string">&#x27;AppName&#x27;</span>:<span class="string">&#x27;vipservermailG1&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>再次查询时，时间已变为东八区时间。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5f646902ee75270c044f15d2&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;Version&#x27;</span>: <span class="string">&#x27;1.0&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;TypeName&#x27;</span>: <span class="string">&#x27;运行&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;HappenTime&#x27;</span>: datetime.datetime(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">605000</span>),  <span class="comment"># 加了8小时</span></span><br><span class="line">    <span class="string">&#x27;AppName&#x27;</span>: <span class="string">&#x27;vipservermailG1&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;AppFriendlyName&#x27;</span>: <span class="string">&#x27;邮件服务&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ok，问题完美解决，不过既然涉及到了时区相关的问题，就顺便补一下这方面的知识，从源头上彻底了解一下时间的相关概念，以后再遇到类似的问题会游刃有余。</p>
<h3 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h3><p>GMT（Greenwich Mean Time）， 格林威治平时（也称格林威治时间）。</p>
<p>它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。</p>
<h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>UTC（Coodinated Universal Time），协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</p>
<p>UTC 是现在全球通用的时间标准，全球各地都同意将各自的时间进行同步协调。UTC 时间是经过平均太阳时（以格林威治时间GMT为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成。</p>
<h3 id="UTC-vs-GMT"><a href="#UTC-vs-GMT" class="headerlink" title="UTC vs GMT"></a>UTC vs GMT</h3><p>GMT是前世界标准时，UTC是现世界标准时。</p>
<p>UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。</p>
<p>但在不需要精确到秒的情况下，二者可以视为等同。</p>
<p>每年格林尼治天文台会发调时信息，基于UTC。</p>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时间戳是一个数字，定义为格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。<strong>注意，同一时刻，不同时区获得的时间戳是相同的。</strong>以前很多用来记录时间的字段，在数据库中往往不会存储为Datetime类型，而是直接存储为无符号整形，存放时间戳的值。</p>
<p>Python获取时间戳的代码为</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">int(time.time())</span><br></pre></td></tr></table></figure>

<h3 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h3><p>当前时区的本地时间</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">import datetime</span><br><span class="line">datetime.datetime.now()</span><br></pre></td></tr></table></figure>

<p>上面的输出值为</p>
<blockquote>
<p>2020-03-20 18:50:03.23743</p>
</blockquote>
<h3 id="标准时间"><a href="#标准时间" class="headerlink" title="标准时间"></a>标准时间</h3><p>本地时间只包括当前的时间，不包含任何时区信息。同一时刻，东八区的本地时间比零时区的本地时间快了8个小时。在不同时区之间交换时间数据，除了用纯数字的时间戳，还有一种更方便人类阅读的表示方式：标准时间的偏移量表示方法。</p>
<p>RFC3339详细定义了互联网上日期/时间的偏移量表示：</p>
<blockquote>
<p>2020-03-20T00:00:00.00Z</p>
</blockquote>
<p>这个代表了UTC时间的2017年12月08日零时</p>
<blockquote>
<p>2020-03-20T00:08:00.00+08:00</p>
</blockquote>
<p>这个代表了同一时刻的，东八区北京时间（CST）表示的方法</p>
<p>上面两个时间的时间戳是等价的。两个的区别，就是在本地时间后面增加了时区信息。Z表示零时区。+08:00表示UTC时间增加8小时。</p>
<p>这种表示方式容易让人疑惑的点是从标准时间换算UTC时间。以CST转换UTC为例，没有看文档的情况下，根据 +08:00 的结尾，很容易根据直觉在本地时间再加上8小时。正确的计算方法是本地时间减去多增加的8小时。+08:00减去8小时才是UTC时间，-08:00加上8小时才是UTC时间。</p>
<h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><strong>champyin</strong>：<a href="%5Bhttps://champyin.com/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6%5D(https://link.zhihu.com/?target=https://champyin.com/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6)">彻底弄懂GMT、UTC、时区和夏令时</a></p>
<p><strong>柳纯</strong>：<a href="https://ldsink.com/articles/date-and-time-on-the-internet/">互联网上的日期和时间</a></p>
]]></content>
      <categories>
        <category>踩坑</category>
        <category>总结</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>pymongo</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器使用总结</title>
    <url>/posts/5690c2ee.html</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在学习自动化测试框架<strong>unittest</strong>、<strong>pytest</strong>的时候，发现有很多类或者函数头上会带一顶**@<strong>开头的帽子，尤其是</strong>pytest<strong>中，很多核心的用法（像参数化、夹具等）都是通过这个家伙来实现的，看起来很高端的样子，那么这玩意到底是什么呢？它就是python中的一个重难点：</strong>装饰器**。</p>
<p>说到装饰器，那么就必须先了解另一个概念，<strong>闭包</strong>。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>什么是<strong>闭包</strong>？简单来说就是<strong>一个函数定义中引用了函数外定义的变量，并且该函数可以在其定义环境外被执行，这样的一个函数我们称之为闭包</strong>。</p>
<blockquote>
<p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p>
</blockquote>
<p>直接上栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    greetings = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> greetings + name</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">print(outer()(<span class="string">&#x27;古一&#x27;</span>)) <span class="comment"># 输出：hello 古一</span></span><br></pre></td></tr></table></figure>

<p>上面代码的意思：定义了一个外层函数<code>outer</code>和一个内部函数<code>inner</code>；在<code>outer</code>函数内部，又定义了一个变量<code>greetings</code>并赋值；然后在内部函数<code>inner</code>中调用了这个变量；最后<code>outer</code>函数的返回就是<code>inner</code>函数本身。</p>
<p>我们将其分解来看，先调用函数<code>outer</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(outer())</span><br><span class="line"><span class="comment"># 输出： &lt;function outer.&lt;locals&gt;.inner at 0x0000024AEF221E50&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>outer</code>返回了一个函数，其实就是它的内层函数<code>inner</code>，<code>outer()(&#39;古一&#39;)</code>这一句其实就等同于<code>inner(&#39;古一&#39;)</code>。</p>
<p>当我们用调试模式去走读这个闭包函数可以发现，进入<code>outer</code>函数内部后，当执行到<code>def inner(name):</code>这里后，并不会马上进入<code>inner</code>函数的内部，而是先执行<code>return inner</code>这句，即先走完外层函数<code>outer</code>的生命周期，然后才会开始进入<code>inner</code>内部，而且，虽然外层函数的生命周期已经结束，但是**内层函数<code>inner</code>仍然可以调用<code>outer</code>的局部变量<code>greeting</code>**！这就是闭包的特别之处。</p>
<p>由此，我们可以简单总结出闭包的特点：</p>
<ul>
<li>函数中嵌套了另一个函数</li>
<li>外层函数的返回值是嵌套的内层函数</li>
<li>内层函数对外部函数有访问（即对外部作用域有非全局变量的引用）</li>
</ul>
<p>说了这么多闭包的东西，它跟装饰器有什么关系呢？</p>
<p>装饰器其实就是闭包在python中的一种经典引用，它能让python代码更简洁逼格更高，也能夹带更多“私货”。</p>
<h3 id="实现装饰器"><a href="#实现装饰器" class="headerlink" title="实现装饰器"></a>实现装饰器</h3><p>在我平时写自动化测试框架时，会自己定义一些装饰器来减少代码冗余，简化代码，如用装饰器实现日志输出等。</p>
<p>先看一个栗子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>这个是一个加法函数，现在我有一个新需求：我想把传入的是什么参数以及函数的运行时间，用日志打印出来，那么直接改原函数也很简单能实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    res = a + b</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    run_time = end_time - start_time</span><br><span class="line">    logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>嗯，这个<strong>扩展</strong>的功能看起来还不错，我想给减法、乘法、除法甚至更多函数也加上这个功能，那么问题来了，那么多函数我都要一一去加上这么一长串东西吗？显然不合适。另一方面，直接修改原函数，也是不符合面向对象编程原则之一：<strong>开放封闭原则</strong>的。</p>
<blockquote>
<p>封闭：已经实现的功能代码对修改是封闭的。</p>
<p>开放：已经实现的功能代码对扩展是开放的。</p>
</blockquote>
<p>那么我们怎么解决这个问题?</p>
<p>首先我们上面说到过闭包，我们用外函数和内函数来实现以下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外层函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 内层被装饰的功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 功能函数</span></span><br><span class="line">        res = func(a, b)</span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 真正的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过外函数、内函数和功能函数，实现了在不改变原功能函数的情况下的功能扩展</span></span><br><span class="line">print(extended(add)(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p><code>extended</code>就是外层函数，<code>wrapper</code>就是内层函数，即被扩展的功能函数，只不过在这里内层函数对外层引用的变量是个函数，运行一下，看下效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| INFO     | __main__:wrapper:34 - 传入的参数为：1,2</span><br><span class="line">3</span><br><span class="line">| INFO     | __main__:wrapper:40 - 函数的运行时间为：1.000391960144043</span><br></pre></td></tr></table></figure>

<p>ok，有了这个装饰器，我们就可以对我们想要扩展的函数尽情装饰了。</p>
<p><strong>but！这里还会有两个问题</strong>：</p>
<p>1、如果要装饰的函数只有1个或者3个、4个甚至有关键字参数呢</p>
<p>2、我们的调用仍然很麻烦，extended(add)(1, 2)的调用方式，不容易让使用者理解我们这个函数是在做什么</p>
<p>针对第一个问题，其实很好解决，python中给我们提供了不定长参数<code>*args</code>和<code>**kwargs**</code>，因此我们只需要做一个简单的修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 内层被装饰的功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;args，kwargs&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 功能函数</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>来试试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span>(<span class="params">a, b, c, d=None</span>):</span></span><br><span class="line">    res = a + b + c + d</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(extended(add2)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d=<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| INFO     | __main__:wrapper:34 - 传入的参数为：(1, 2, 3),&#123;&#39;d&#39;: 4&#125;</span><br><span class="line">10</span><br><span class="line">| INFO     | __main__:wrapper:40 - 函数的运行时间为：1.0007085800170898</span><br></pre></td></tr></table></figure>

<p>通过不定长参数，让我们的装饰器更加通用了。</p>
<p>回到第二个问题，其实Python为了让大家写起来方便，给装饰器提供了一个<strong>语法糖</strong>，这就很pythonic了，用法如下：</p>
<blockquote>
<p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;args&#125;</span>,<span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接戴一顶帽子</span></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>通过在功能函数上加<code>@</code>即可直接调用装饰器，这样有利于让我们把更多的注意力放在功能函数本身。</p>
<p>至此，我们就实现了一个基础且通用的装饰器。</p>
<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>ok，新需求又来了，如果想通过装饰器传参给功能函数怎么办呢？比如我想通过从外部传入一个名字，打印是谁在调用这个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里的name该从哪里传进来呢？</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给装饰器传入&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">@extended(&#x27;kevin&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这样写肯定会报错，问题的关键在于如何去接收这个传入的参数，其实我们只需要在原来的装饰器外面再加一层用来接收外部参数即可，先上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加了一层用来接收外部参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="comment"># 返回第二层函数</span></span><br><span class="line">    <span class="keyword">return</span> extended</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的装饰器不再是extended,而是add_name</span></span><br><span class="line"><span class="meta">@add_name(&#x27;kevin&#x27;) # 等同于：add = add_name(&#x27;kevin&#x27;)(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>我们把原来的装饰器<code>extended</code>看做一个整体，即一个内层函数，<code>add_name</code>就是它的外层函数，外层作用域中有一个变量<code>name</code>传入，上面闭包中讲过，内层是可以引用外部作用域的变量的，因此，在最里层的功能函数，就可以直接引用这个<code>name</code>。于是，通过再嵌套一层，实现了我们新增的需求。</p>
<h3 id="原函数还是原函数吗？"><a href="#原函数还是原函数吗？" class="headerlink" title="原函数还是原函数吗？"></a>原函数还是原函数吗？</h3><p>在使用装饰器后，有一个值得注意的地方，还是上面的第一个例子，我们先打印出<code>add()</code>函数的一些元信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(add.__name__)</span><br><span class="line"><span class="comment"># 输出： &#x27;wrapper&#x27;</span></span><br><span class="line">help(add)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure>

<p>我们发现，<code>add()</code>函数被装饰以后，它的元信息变了。元信息告诉我们“它不再是以前那个add()函数，而是被wrapper()取代了”。这是装饰器带来的一个副作用，会覆盖掉原函数的元信息。</p>
<p>为了解决这问题，可以通过内置的装饰器<code>@functools.wrap</code>解决，它能帮助保留原函数的元信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wrap(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里的name该从哪里传进来呢？</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给装饰器传入&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">@extended(&#x27;kevin&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(add.__name__)</span><br><span class="line"><span class="comment"># 输出：&#x27;add&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="叠加装饰器"><a href="#叠加装饰器" class="headerlink" title="叠加装饰器"></a>叠加装饰器</h3><p>我们不满足于只给函数扩展一个功能，想给它同时扩展不同的功能，我们可以直接在功能函数上直接叠加使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;叠加装饰器&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>那么当有多个装饰器时，程序的运行顺序是怎么样的呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended1</span>(<span class="params">func1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我是装饰器1&#x27;</span>) <span class="comment"># step3：开始执行装饰器1</span></span><br><span class="line">        res = func1(*args, **kwargs) <span class="comment"># step4：此时func1=wrapper2()=add()</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器1的尾巴&#x27;</span>) <span class="comment"># step6：继续装饰器1剩余的装饰</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># step7： 返回res，装饰器1装饰完毕</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended2</span>(<span class="params">func2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我是装饰器2&#x27;</span>) <span class="comment"># step1：先执行装饰器2</span></span><br><span class="line">        res = func2(*args, **kwargs) <span class="comment"># step2:此时func2=add(),但此时还不会执行add()函数                                本身，因为add()函数还有一个装饰器1，所以此时进入装饰器1</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器2的尾巴&#x27;</span>) <span class="comment"># step8：继续装饰器2剩余的装饰</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># step9:所有装饰完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@extended2</span></span><br><span class="line"><span class="meta">@extended1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span> <span class="comment"># step5：执行完功能函数</span></span><br><span class="line">    print(<span class="string">&#x27;我是功能函数&#x27;</span>)</span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数执行顺序：add()--&gt;wrapper2()--&gt;func2()--&gt;wrapper1()--&gt;func1()--&gt;add()</span></span><br><span class="line"><span class="string">装饰器装饰顺序：</span></span><br><span class="line"><span class="string">1、@extend2：add()--&gt;extend2()--&gt;func2=add原函数--&gt;add指向wrapper2</span></span><br><span class="line"><span class="string">2、@extend1：wrapper2--&gt;extend1()--&gt;func1=wrapper2--&gt;add指向wrapper1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是装饰器2</span><br><span class="line">我是装饰器1</span><br><span class="line">我是功能函数</span><br><span class="line">装饰器1的尾巴</span><br><span class="line">装饰器2的尾巴</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p><strong>装饰器执行顺序：从上往下</strong></p>
<p><strong>装饰器装饰顺序：从下往上</strong></p>
<h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>上文中说到的装饰器，装饰对象都是函数，那么能否装饰类呢？答案是可以的。</p>
<p>假如我们要给不同的类增加一个属性，</p>
<p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">cls</span>):</span></span><br><span class="line">    cls.name = <span class="string">&#x27;kevin&#x27;</span></span><br><span class="line">    cls.age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A.name) <span class="comment"># 输出kevin</span></span><br><span class="line">print(A.age) <span class="comment"># 输出18</span></span><br><span class="line">print(B.name) <span class="comment"># 输出kevin</span></span><br><span class="line">print(B.age) <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure>

<p>方法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        cls.name = <span class="string">&#x27;Annie&#x27;</span></span><br><span class="line">        cls.age = <span class="number">18</span></span><br><span class="line">        <span class="keyword">return</span> cls(*args, **kwargs) <span class="comment"># 返回的是A(),即对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@extended  # A = extended(A)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A()) <span class="comment"># 类型为对象</span></span><br><span class="line">print(A().name) <span class="comment"># Annie</span></span><br><span class="line">print(A().age) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure>

<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>在python中有三个内置装饰器：<code>@classmethod</code>，<code>@staticmethod</code>，<code>@property</code>，查看这三个装饰器源码可以发现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    classmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a function to be a class method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A class method receives the class as implicit first argument,</span></span><br><span class="line"><span class="string">    just like an instance method receives the instance.</span></span><br><span class="line"><span class="string">    To declare a class method, use this idiom:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">      class C:</span></span><br><span class="line"><span class="string">          @classmethod</span></span><br><span class="line"><span class="string">          def f(cls, arg1, arg2, ...):</span></span><br><span class="line"><span class="string">              ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()).  The instance is ignored except for its class.</span></span><br><span class="line"><span class="string">    If a class method is called for a derived class, the derived class</span></span><br><span class="line"><span class="string">    object is passed as the implied first argument.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Class methods are different than C++ or Java static methods.</span></span><br><span class="line"><span class="string">    If you want those, see the staticmethod builtin.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    __func__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    staticmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a function to be a static method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A static method does not receive an implicit first argument.</span></span><br><span class="line"><span class="string">    To declare a static method, use this idiom:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">         class C:</span></span><br><span class="line"><span class="string">             @staticmethod</span></span><br><span class="line"><span class="string">             def f(arg1, arg2, ...):</span></span><br><span class="line"><span class="string">                 ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()). Both the class and the instance are ignored, and</span></span><br><span class="line"><span class="string">    neither is passed implicitly as the first argument to the method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Static methods in Python are similar to those found in Java or C++.</span></span><br><span class="line"><span class="string">    For a more advanced concept, see the classmethod builtin.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    __func__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Property attribute.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">      fget</span></span><br><span class="line"><span class="string">        function to be used for getting an attribute value</span></span><br><span class="line"><span class="string">      fset</span></span><br><span class="line"><span class="string">        function to be used for setting an attribute value</span></span><br><span class="line"><span class="string">      fdel</span></span><br><span class="line"><span class="string">        function to be used for del&#x27;ing an attribute</span></span><br><span class="line"><span class="string">      doc</span></span><br><span class="line"><span class="string">        docstring</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Typical use is to define a managed attribute x:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        def getx(self): return self._x</span></span><br><span class="line"><span class="string">        def setx(self, value): self._x = value</span></span><br><span class="line"><span class="string">        def delx(self): del self._x</span></span><br><span class="line"><span class="string">        x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Decorators make defining new properties or modifying existing ones easy:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        @property</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            &quot;I am the &#x27;x&#x27; property.&quot;</span></span><br><span class="line"><span class="string">            return self._x</span></span><br><span class="line"><span class="string">        @x.setter</span></span><br><span class="line"><span class="string">        def x(self, value):</span></span><br><span class="line"><span class="string">            self._x = value</span></span><br><span class="line"><span class="string">        @x.deleter</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            del self._x</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the deleter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the getter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the setter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Delete an attribute of instance. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget=None, fset=None, fdel=None, doc=None</span>):</span> <span class="comment"># known special case of property.__init__</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Property attribute.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">          fget</span></span><br><span class="line"><span class="string">            function to be used for getting an attribute value</span></span><br><span class="line"><span class="string">          fset</span></span><br><span class="line"><span class="string">            function to be used for setting an attribute value</span></span><br><span class="line"><span class="string">          fdel</span></span><br><span class="line"><span class="string">            function to be used for del&#x27;ing an attribute</span></span><br><span class="line"><span class="string">          doc</span></span><br><span class="line"><span class="string">            docstring</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Typical use is to define a managed attribute x:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        class C(object):</span></span><br><span class="line"><span class="string">            def getx(self): return self._x</span></span><br><span class="line"><span class="string">            def setx(self, value): self._x = value</span></span><br><span class="line"><span class="string">            def delx(self): del self._x</span></span><br><span class="line"><span class="string">            x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Decorators make defining new properties or modifying existing ones easy:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        class C(object):</span></span><br><span class="line"><span class="string">            @property</span></span><br><span class="line"><span class="string">            def x(self):</span></span><br><span class="line"><span class="string">                &quot;I am the &#x27;x&#x27; property.&quot;</span></span><br><span class="line"><span class="string">                return self._x</span></span><br><span class="line"><span class="string">            @x.setter</span></span><br><span class="line"><span class="string">            def x(self, value):</span></span><br><span class="line"><span class="string">                self._x = value</span></span><br><span class="line"><span class="string">            @x.deleter</span></span><br><span class="line"><span class="string">            def x(self):</span></span><br><span class="line"><span class="string">                del self._x</span></span><br><span class="line"><span class="string">        # (copied from class doc)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Set an attribute of instance to value. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    fdel = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    fget = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    fset = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br></pre></td></tr></table></figure>

<p>其实这三个装饰器，都不是函数实现而是用类实现的。</p>
<p>如果要用类实现装饰器，会涉及到一个魔术方法<code>__call__</code>，先看看这个方法的作用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;这是实例初始化方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = A() <span class="comment"># 输出：这是实例初始化方法</span></span><br><span class="line">m() <span class="comment"># 报错：TypeError: &#x27;A&#x27; object is not callable A的对象不可调用</span></span><br></pre></td></tr></table></figure>

<p>由上可知，当给一个实例对象加上<code>()</code>，它是无法被调用的，如果想让它能像函数一样被调用，就必须加上<code>__call__</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;这是实例初始化方法&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;执行__call__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = A() <span class="comment"># 输出：这是实例初始化方法</span></span><br><span class="line">m() <span class="comment"># 输出：执行__call__</span></span><br></pre></td></tr></table></figure>

<p>所以，当实例对象加上()后，就会自动触发<code>__call__</code>方法。</p>
<p>那么有了这个魔术方法的加持，我们就可以用类去实现装饰器了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">decorator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span> <span class="comment"># func = demo</span></span><br><span class="line">        print(<span class="string">&#x27;开始实例化对象&#x27;</span>)</span><br><span class="line">        self.func = func <span class="comment"># self.demo = demo</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器扩展的功能1&#x27;</span>)</span><br><span class="line">        self.func() <span class="comment"># self.demo()</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器扩展的功能2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator # demo = decorator(demo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;执行功能函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<p>首先，我们创建了一个类<code>decorator</code>，它的初始化方法中会传入一个参数<code>func</code>，并将这个参数设置为实例属性<code>self.func</code>，当函数<code>demo()</code>执行时，会先进行装饰<code>@decorator</code>，即执行<code>__init__</code>，此时<code>demo = decorator(demo)</code>，即<code>demo</code>现在是一个<code>decorator</code>类的实例对象，又由于给<code>demo</code>对象加了括号，即调用实例对象，那么此时<code>__call__</code>方法就会触发，先执行扩展功能1，再执行原函数，最后执行扩展功能2，所以最后得到的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开始实例化对象</span><br><span class="line">装饰器扩展的功能1</span><br><span class="line">执行功能函数</span><br><span class="line">装饰器扩展的功能2</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>python中的装饰器无非就是以上几类，<strong>所谓装饰器，其实就是通过装饰器函数（或类），来修改原函数（或类）的一些功能，使得原函数（或类）不需要修改。</strong></p>
<blockquote>
<p>Decorators is to modify the behavior of the function through a wrapper so we don’t have to actually modify the function.</p>
</blockquote>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
