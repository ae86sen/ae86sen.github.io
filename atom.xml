<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AncientOne</title>
  <icon>https://www.gravatar.com/avatar/4e3cae70676836332f50813e82784cb7</icon>
  <subtitle>古一的时空间</subtitle>
  <link href="http://ancientone.cf/atom.xml" rel="self"/>
  
  <link href="http://ancientone.cf/"/>
  <updated>2020-11-23T09:00:12.473Z</updated>
  <id>http://ancientone.cf/</id>
  
  <author>
    <name>古一</name>
    <email>listeningsss@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>装饰器使用总结</title>
    <link href="http://ancientone.cf/posts/5690c2ee.html"/>
    <id>http://ancientone.cf/posts/5690c2ee.html</id>
    <published>2020-11-22T15:45:23.000Z</published>
    <updated>2020-11-23T09:00:12.473Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在学习自动化测试框架<strong>unittest</strong>、<strong>pytest</strong>的时候，发现有很多类或者函数头上会带一顶**@<strong>开头的帽子，尤其是</strong>pytest<strong>中，很多核心的用法（像参数化、夹具等）都是通过这个家伙来实现的，看起来很高端的样子，那么这玩意到底是什么呢？它就是python中的一个重难点：</strong>装饰器**。</p><p>说到装饰器，那么就必须先了解另一个概念，<strong>闭包</strong>。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>什么是<strong>闭包</strong>？简单来说就是<strong>一个函数定义中引用了函数外定义的变量，并且该函数可以在其定义环境外被执行，这样的一个函数我们称之为闭包</strong>。</p><blockquote><p>在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。</p></blockquote><p>直接上栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">    greetings = <span class="string">&#x27;hello &#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">name</span>):</span></span><br><span class="line">        <span class="keyword">return</span> greetings + name</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line">print(outer()(<span class="string">&#x27;古一&#x27;</span>)) <span class="comment"># 输出：hello 古一</span></span><br></pre></td></tr></table></figure><p>上面代码的意思：定义了一个外层函数<code>outer</code>和一个内部函数<code>inner</code>；在<code>outer</code>函数内部，又定义了一个变量<code>greetings</code>并赋值；然后在内部函数<code>inner</code>中调用了这个变量；最后<code>outer</code>函数的返回就是<code>inner</code>函数本身。</p><p>我们将其分解来看，先调用函数<code>outer</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(outer())</span><br><span class="line"><span class="comment"># 输出： &lt;function outer.&lt;locals&gt;.inner at 0x0000024AEF221E50&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到<code>outer</code>返回了一个函数，其实就是它的内层函数<code>inner</code>，<code>outer()(&#39;古一&#39;)</code>这一句其实就等同于<code>inner(&#39;古一&#39;)</code>。</p><p>当我们用调试模式去走读这个闭包函数可以发现，进入<code>outer</code>函数内部后，当执行到<code>def inner(name):</code>这里后，并不会马上进入<code>inner</code>函数的内部，而是先执行<code>return inner</code>这句，即先走完外层函数<code>outer</code>的生命周期，然后才会开始进入<code>inner</code>内部，而且，虽然外层函数的生命周期已经结束，但是**内层函数<code>inner</code>仍然可以调用<code>outer</code>的局部变量<code>greeting</code>**！这就是闭包的特别之处。</p><p>由此，我们可以简单总结出闭包的特点：</p><ul><li>函数中嵌套了另一个函数</li><li>外层函数的返回值是嵌套的内层函数</li><li>内层函数对外部函数有访问（即对外部作用域有非全局变量的引用）</li></ul><p>说了这么多闭包的东西，它跟装饰器有什么关系呢？</p><p>装饰器其实就是闭包在python中的一种经典引用，它能让python代码更简洁逼格更高，也能夹带更多“私货”。</p><h3 id="实现装饰器"><a href="#实现装饰器" class="headerlink" title="实现装饰器"></a>实现装饰器</h3><p>在我平时写自动化测试框架时，会自己定义一些装饰器来减少代码冗余，简化代码，如用装饰器实现日志输出等。</p><p>先看一个栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>这个是一个加法函数，现在我有一个新需求：我想把传入的是什么参数以及函数的运行时间，用日志打印出来，那么直接改原函数也很简单能实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    res = a + b</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    run_time = end_time - start_time</span><br><span class="line">    logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>嗯，这个<strong>扩展</strong>的功能看起来还不错，我想给减法、乘法、除法甚至更多函数也加上这个功能，那么问题来了，那么多函数我都要一一去加上这么一长串东西吗？显然不合适。另一方面，直接修改原函数，也是不符合面向对象编程原则之一：<strong>开放封闭原则</strong>的。</p><blockquote><p>封闭：已经实现的功能代码对修改是封闭的。</p><p>开放：已经实现的功能代码对扩展是开放的。</p></blockquote><p>那么我们怎么解决这个问题?</p><p>首先我们上面说到过闭包，我们用外函数和内函数来实现以下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外层函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 内层被装饰的功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;a&#125;</span>,<span class="subst">&#123;b&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 功能函数</span></span><br><span class="line">        res = func(a, b)</span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 真正的功能函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过外函数、内函数和功能函数，实现了在不改变原功能函数的情况下的功能扩展</span></span><br><span class="line">print(extended(add)(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><code>extended</code>就是外层函数，<code>wrapper</code>就是内层函数，即被扩展的功能函数，只不过在这里内层函数对外层引用的变量是个函数，运行一下，看下效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| INFO     | __main__:wrapper:34 - 传入的参数为：1,2</span><br><span class="line">3</span><br><span class="line">| INFO     | __main__:wrapper:40 - 函数的运行时间为：1.000391960144043</span><br></pre></td></tr></table></figure><p>ok，有了这个装饰器，我们就可以对我们想要扩展的函数尽情装饰了。</p><p><strong>but！这里还会有两个问题</strong>：</p><p>1、如果要装饰的函数只有1个或者3个、4个甚至有关键字参数呢</p><p>2、我们的调用仍然很麻烦，extended(add)(1, 2)的调用方式，不容易让使用者理解我们这个函数是在做什么</p><p>针对第一个问题，其实很好解决，python中给我们提供了不定长参数<code>*args</code>和<code>**kwargs**</code>，因此我们只需要做一个简单的修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="comment"># 内层被装饰的功能函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;args，kwargs&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        <span class="comment"># 功能函数</span></span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># 扩展的功能</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span>(<span class="params">a, b, c, d=None</span>):</span></span><br><span class="line">    res = a + b + c + d</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(extended(add2)(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, d=<span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| INFO     | __main__:wrapper:34 - 传入的参数为：(1, 2, 3),&#123;&#39;d&#39;: 4&#125;</span><br><span class="line">10</span><br><span class="line">| INFO     | __main__:wrapper:40 - 函数的运行时间为：1.0007085800170898</span><br></pre></td></tr></table></figure><p>通过不定长参数，让我们的装饰器更加通用了。</p><p>回到第二个问题，其实Python为了让大家写起来方便，给装饰器提供了一个<strong>语法糖</strong>，这就很pythonic了，用法如下：</p><blockquote><p>语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·约翰·兰达（Peter J. Landin）发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        logger.info(<span class="string">f&#x27;传入的参数为：<span class="subst">&#123;args&#125;</span>,<span class="subst">&#123;kwargs&#125;</span>&#x27;</span>)</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        run_time = end_time - start_time</span><br><span class="line">        logger.info(<span class="string">f&#x27;函数的运行时间为：<span class="subst">&#123;run_time&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接戴一顶帽子</span></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>通过在功能函数上加<code>@</code>即可直接调用装饰器，这样有利于让我们把更多的注意力放在功能函数本身。</p><p>至此，我们就实现了一个基础且通用的装饰器。</p><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>ok，新需求又来了，如果想通过装饰器传参给功能函数怎么办呢？比如我想通过从外部传入一个名字，打印是谁在调用这个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里的name该从哪里传进来呢？</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给装饰器传入&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">@extended(&#x27;kevin&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>这样写肯定会报错，问题的关键在于如何去接收这个传入的参数，其实我们只需要在原来的装饰器外面再加一层用来接收外部参数即可，先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加了一层用来接收外部参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="comment"># 返回第二层函数</span></span><br><span class="line">    <span class="keyword">return</span> extended</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用的装饰器不再是extended,而是add_name</span></span><br><span class="line"><span class="meta">@add_name(&#x27;kevin&#x27;) # 等同于：add = add_name(&#x27;kevin&#x27;)(add)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>我们把原来的装饰器<code>extended</code>看做一个整体，即一个内层函数，<code>add_name</code>就是它的外层函数，外层作用域中有一个变量<code>name</code>传入，上面闭包中讲过，内层是可以引用外部作用域的变量的，因此，在最里层的功能函数，就可以直接引用这个<code>name</code>。于是，通过再嵌套一层，实现了我们新增的需求。</p><h3 id="原函数还是原函数吗？"><a href="#原函数还是原函数吗？" class="headerlink" title="原函数还是原函数吗？"></a>原函数还是原函数吗？</h3><p>在使用装饰器后，有一个值得注意的地方，还是上面的第一个例子，我们先打印出<code>add()</code>函数的一些元信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(add.__name__)</span><br><span class="line"><span class="comment"># 输出： &#x27;wrapper&#x27;</span></span><br><span class="line">help(add)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Help on function wrapper in module __main__:</span></span><br><span class="line"><span class="comment"># wrapper(*args, **kwargs)</span></span><br></pre></td></tr></table></figure><p>我们发现，<code>add()</code>函数被装饰以后，它的元信息变了。元信息告诉我们“它不再是以前那个add()函数，而是被wrapper()取代了”。这是装饰器带来的一个副作用，会覆盖掉原函数的元信息。</p><p>为了解决这问题，可以通过内置的装饰器<code>@functools.wrap</code>解决，它能帮助保留原函数的元信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wrap(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里的name该从哪里传进来呢？</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>正在调用该函数&#x27;</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给装饰器传入&#x27;kevin&#x27;</span></span><br><span class="line"><span class="meta">@extended(&#x27;kevin&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">print(add.__name__)</span><br><span class="line"><span class="comment"># 输出：&#x27;add&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="叠加装饰器"><a href="#叠加装饰器" class="headerlink" title="叠加装饰器"></a>叠加装饰器</h3><p>我们不满足于只给函数扩展一个功能，想给它同时扩展不同的功能，我们可以直接在功能函数上直接叠加使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;叠加装饰器&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么当有多个装饰器时，程序的运行顺序是怎么样的呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended1</span>(<span class="params">func1</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我是装饰器1&#x27;</span>) <span class="comment"># step3：开始执行装饰器1</span></span><br><span class="line">        res = func1(*args, **kwargs) <span class="comment"># step4：此时func1=wrapper2()=add()</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器1的尾巴&#x27;</span>) <span class="comment"># step6：继续装饰器1剩余的装饰</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># step7： 返回res，装饰器1装饰完毕</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended2</span>(<span class="params">func2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我是装饰器2&#x27;</span>) <span class="comment"># step1：先执行装饰器2</span></span><br><span class="line">        res = func2(*args, **kwargs) <span class="comment"># step2:此时func2=add(),但此时还不会执行add()函数                                本身，因为add()函数还有一个装饰器1，所以此时进入装饰器1</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器2的尾巴&#x27;</span>) <span class="comment"># step8：继续装饰器2剩余的装饰</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="comment"># step9:所有装饰完毕</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@extended2</span></span><br><span class="line"><span class="meta">@extended1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">a, b</span>):</span> <span class="comment"># step5：执行完功能函数</span></span><br><span class="line">    print(<span class="string">&#x27;我是功能函数&#x27;</span>)</span><br><span class="line">    res = a + b</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">函数执行顺序：add()--&gt;wrapper2()--&gt;func2()--&gt;wrapper1()--&gt;func1()--&gt;add()</span></span><br><span class="line"><span class="string">装饰器装饰顺序：</span></span><br><span class="line"><span class="string">1、@extend2：add()--&gt;extend2()--&gt;func2=add原函数--&gt;add指向wrapper2</span></span><br><span class="line"><span class="string">2、@extend1：wrapper2--&gt;extend1()--&gt;func1=wrapper2--&gt;add指向wrapper1</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我是装饰器2</span><br><span class="line">我是装饰器1</span><br><span class="line">我是功能函数</span><br><span class="line">装饰器1的尾巴</span><br><span class="line">装饰器2的尾巴</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>总结：</p><p><strong>装饰器执行顺序：从上往下</strong></p><p><strong>装饰器装饰顺序：从下往上</strong></p><h3 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h3><p>上文中说到的装饰器，装饰对象都是函数，那么能否装饰类呢？答案是可以的。</p><p>假如我们要给不同的类增加一个属性，</p><p>方法一：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">cls</span>):</span></span><br><span class="line">    cls.name = <span class="string">&#x27;kevin&#x27;</span></span><br><span class="line">    cls.age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@extended</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A.name) <span class="comment"># 输出kevin</span></span><br><span class="line">print(A.age) <span class="comment"># 输出18</span></span><br><span class="line">print(B.name) <span class="comment"># 输出kevin</span></span><br><span class="line">print(B.age) <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extended</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        cls.name = <span class="string">&#x27;Annie&#x27;</span></span><br><span class="line">        cls.age = <span class="number">18</span></span><br><span class="line">        <span class="keyword">return</span> cls(*args, **kwargs) <span class="comment"># 返回的是A(),即对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@extended  # A = extended(A)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(A()) <span class="comment"># 类型为对象</span></span><br><span class="line">print(A().name) <span class="comment"># Annie</span></span><br><span class="line">print(A().age) <span class="comment"># 18</span></span><br></pre></td></tr></table></figure><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>在python中有三个内置装饰器：<code>@classmethod</code>，<code>@staticmethod</code>，<code>@property</code>，查看这三个装饰器源码可以发现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classmethod</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    classmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a function to be a class method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A class method receives the class as implicit first argument,</span></span><br><span class="line"><span class="string">    just like an instance method receives the instance.</span></span><br><span class="line"><span class="string">    To declare a class method, use this idiom:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">      class C:</span></span><br><span class="line"><span class="string">          @classmethod</span></span><br><span class="line"><span class="string">          def f(cls, arg1, arg2, ...):</span></span><br><span class="line"><span class="string">              ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()).  The instance is ignored except for its class.</span></span><br><span class="line"><span class="string">    If a class method is called for a derived class, the derived class</span></span><br><span class="line"><span class="string">    object is passed as the implied first argument.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Class methods are different than C++ or Java static methods.</span></span><br><span class="line"><span class="string">    If you want those, see the staticmethod builtin.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    __func__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">staticmethod</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    staticmethod(function) -&gt; method</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a function to be a static method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    A static method does not receive an implicit first argument.</span></span><br><span class="line"><span class="string">    To declare a static method, use this idiom:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">         class C:</span></span><br><span class="line"><span class="string">             @staticmethod</span></span><br><span class="line"><span class="string">             def f(arg1, arg2, ...):</span></span><br><span class="line"><span class="string">                 ...</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    It can be called either on the class (e.g. C.f()) or on an instance</span></span><br><span class="line"><span class="string">    (e.g. C().f()). Both the class and the instance are ignored, and</span></span><br><span class="line"><span class="string">    neither is passed implicitly as the first argument to the method.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Static methods in Python are similar to those found in Java or C++.</span></span><br><span class="line"><span class="string">    For a more advanced concept, see the classmethod builtin.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, function</span>):</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    __func__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">property</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Property attribute.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">      fget</span></span><br><span class="line"><span class="string">        function to be used for getting an attribute value</span></span><br><span class="line"><span class="string">      fset</span></span><br><span class="line"><span class="string">        function to be used for setting an attribute value</span></span><br><span class="line"><span class="string">      fdel</span></span><br><span class="line"><span class="string">        function to be used for del&#x27;ing an attribute</span></span><br><span class="line"><span class="string">      doc</span></span><br><span class="line"><span class="string">        docstring</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Typical use is to define a managed attribute x:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        def getx(self): return self._x</span></span><br><span class="line"><span class="string">        def setx(self, value): self._x = value</span></span><br><span class="line"><span class="string">        def delx(self): del self._x</span></span><br><span class="line"><span class="string">        x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Decorators make defining new properties or modifying existing ones easy:</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    class C(object):</span></span><br><span class="line"><span class="string">        @property</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            &quot;I am the &#x27;x&#x27; property.&quot;</span></span><br><span class="line"><span class="string">            return self._x</span></span><br><span class="line"><span class="string">        @x.setter</span></span><br><span class="line"><span class="string">        def x(self, value):</span></span><br><span class="line"><span class="string">            self._x = value</span></span><br><span class="line"><span class="string">        @x.deleter</span></span><br><span class="line"><span class="string">        def x(self):</span></span><br><span class="line"><span class="string">            del self._x</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the deleter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the getter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Descriptor to change the setter on a property. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Delete an attribute of instance. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return an attribute of instance, which is of type owner. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, fget=None, fset=None, fdel=None, doc=None</span>):</span> <span class="comment"># known special case of property.__init__</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Property attribute.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">          fget</span></span><br><span class="line"><span class="string">            function to be used for getting an attribute value</span></span><br><span class="line"><span class="string">          fset</span></span><br><span class="line"><span class="string">            function to be used for setting an attribute value</span></span><br><span class="line"><span class="string">          fdel</span></span><br><span class="line"><span class="string">            function to be used for del&#x27;ing an attribute</span></span><br><span class="line"><span class="string">          doc</span></span><br><span class="line"><span class="string">            docstring</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Typical use is to define a managed attribute x:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        class C(object):</span></span><br><span class="line"><span class="string">            def getx(self): return self._x</span></span><br><span class="line"><span class="string">            def setx(self, value): self._x = value</span></span><br><span class="line"><span class="string">            def delx(self): del self._x</span></span><br><span class="line"><span class="string">            x = property(getx, setx, delx, &quot;I&#x27;m the &#x27;x&#x27; property.&quot;)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        Decorators make defining new properties or modifying existing ones easy:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        class C(object):</span></span><br><span class="line"><span class="string">            @property</span></span><br><span class="line"><span class="string">            def x(self):</span></span><br><span class="line"><span class="string">                &quot;I am the &#x27;x&#x27; property.&quot;</span></span><br><span class="line"><span class="string">                return self._x</span></span><br><span class="line"><span class="string">            @x.setter</span></span><br><span class="line"><span class="string">            def x(self, value):</span></span><br><span class="line"><span class="string">                self._x = value</span></span><br><span class="line"><span class="string">            @x.deleter</span></span><br><span class="line"><span class="string">            def x(self):</span></span><br><span class="line"><span class="string">                del self._x</span></span><br><span class="line"><span class="string">        # (copied from class doc)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">*args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Set an attribute of instance to value. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    fdel = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    fget = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    fset = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br><span class="line"></span><br><span class="line">    __isabstractmethod__ = property(<span class="keyword">lambda</span> self: object(), <span class="keyword">lambda</span> self, v: <span class="literal">None</span>, <span class="keyword">lambda</span> self: <span class="literal">None</span>)  <span class="comment"># default</span></span><br></pre></td></tr></table></figure><p>其实这三个装饰器，都不是函数实现而是用类实现的。</p><p>如果要用类实现装饰器，会涉及到一个魔术方法<code>__call__</code>，先看看这个方法的作用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;这是实例初始化方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = A() <span class="comment"># 输出：这是实例初始化方法</span></span><br><span class="line">m() <span class="comment"># 报错：TypeError: &#x27;A&#x27; object is not callable A的对象不可调用</span></span><br></pre></td></tr></table></figure><p>由上可知，当给一个实例对象加上<code>()</code>，它是无法被调用的，如果想让它能像函数一样被调用，就必须加上<code>__call__</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;这是实例初始化方法&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;执行__call__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">m = A() <span class="comment"># 输出：这是实例初始化方法</span></span><br><span class="line">m() <span class="comment"># 输出：执行__call__</span></span><br></pre></td></tr></table></figure><p>所以，当实例对象加上()后，就会自动触发<code>__call__</code>方法。</p><p>那么有了这个魔术方法的加持，我们就可以用类去实现装饰器了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">decorator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func</span>):</span> <span class="comment"># func = demo</span></span><br><span class="line">        print(<span class="string">&#x27;开始实例化对象&#x27;</span>)</span><br><span class="line">        self.func = func <span class="comment"># self.demo = demo</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器扩展的功能1&#x27;</span>)</span><br><span class="line">        self.func() <span class="comment"># self.demo()</span></span><br><span class="line">        print(<span class="string">&#x27;装饰器扩展的功能2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator # demo = decorator(demo)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;执行功能函数&#x27;</span>)</span><br><span class="line"></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure><p>首先，我们创建了一个类<code>decorator</code>，它的初始化方法中会传入一个参数<code>func</code>，并将这个参数设置为实例属性<code>self.func</code>，当函数<code>demo()</code>执行时，会先进行装饰<code>@decorator</code>，即执行<code>__init__</code>，此时<code>demo = decorator(demo)</code>，即<code>demo</code>现在是一个<code>decorator</code>类的实例对象，又由于给<code>demo</code>对象加了括号，即调用实例对象，那么此时<code>__call__</code>方法就会触发，先执行扩展功能1，再执行原函数，最后执行扩展功能2，所以最后得到的输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始实例化对象</span><br><span class="line">装饰器扩展的功能1</span><br><span class="line">执行功能函数</span><br><span class="line">装饰器扩展的功能2</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>python中的装饰器无非就是以上几类，<strong>所谓装饰器，其实就是通过装饰器函数（或类），来修改原函数（或类）的一些功能，使得原函数（或类）不需要修改。</strong></p><blockquote><p>Decorators is to modify the behavior of the function through a wrapper so we don’t have to actually modify the function.</p></blockquote>]]></content>
    
    
    <summary type="html">python中装饰器分类使用总结</summary>
    
    
    
    <category term="总结" scheme="http://ancientone.cf/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://ancientone.cf/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法总结</title>
    <link href="http://ancientone.cf/posts/da8f1b2e.html"/>
    <id>http://ancientone.cf/posts/da8f1b2e.html</id>
    <published>2020-10-17T15:33:11.000Z</published>
    <updated>2020-12-11T10:42:56.467Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在python中，有一些很特别的方法，它以”__”双下划线开头和结尾，这类方法我们称之为<strong>魔术方法</strong>。这些方法有特殊的用途，有的不需要我们自己去定义，有的我们通过简单的定义可以实现一些神奇的功能。</p><h3 id="init-、-new-和-del"><a href="#init-、-new-和-del" class="headerlink" title="__init__、__new__和__del__"></a>__init__、__new__和__del__</h3><h4 id="构造器：-init-和-new"><a href="#构造器：-init-和-new" class="headerlink" title="构造器：__init__和__new__"></a>构造器：__init__和__new__</h4><p><strong>__init__</strong>应该是我们最为熟悉和常见的一个魔术方法，很多时候，我们会直接把它叫做构造函数，其实不然，在实例一个对象的时候，它并不是第一个被调用的函数，而是一个<strong>__new__</strong>的方法，这两者共同作用才是真正的构造函数。</p><p>看栗子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用init方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用new方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()  </span><br><span class="line"><span class="comment"># 输出结果： 调用new方法</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出结果： None</span></span><br></pre></td></tr></table></figure><p>结果中我们可以发现有两个问题：</p><p>1、当实例对象<code>a</code>时，会自动先去调用<strong>__new__</strong>方法，但是为什么 <strong>__init__</strong>没有被调用呢？</p><p>2、为什么这个实例对象没有创建成功，返回的是<code>None</code>呢？</p><p> <strong>__init__</strong>没有被调用的原因是对象没有创建成功，那为什么对象没有创建成功呢？</p><p>原因是，python3之后，所有的类都是默认继承<code>object</code>类的，我们可以点进<code>object</code>类查看源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">object</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    The base class of the class hierarchy.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    When called, it accepts no arguments and returns a new featureless</span></span><br><span class="line"><span class="string">    instance that has no instance attributes and cannot be given any.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">     @staticmethod # known case of __new__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *more</span>):</span> <span class="comment"># known special case of object.__new__</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Create and return a new object.  See help(type) for accurate signature.         &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>可以看到，基类中有<strong>__new__</strong>方法，而在上面的例子中，我们其实是重写了基类的<strong>__new__</strong>方法!导致它不能真正的去创建对象！(所以<strong>__new__</strong>要慎用，一般情况最好不要去重写)</p><p>我们修改下上面的例子，让类A中的new方法继承基类中的new方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age=None</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        print(<span class="string">&#x27;调用init方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用new方法&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;我是参数args：&#x27;</span>,args)</span><br><span class="line">        print(<span class="string">&#x27;我是参数kwargs&#x27;</span>,kwargs)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&#x27;古一&#x27;</span>,age=<span class="number">18</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">调用new方法</span><br><span class="line">我是参数args： (&lt;class &#x27;__main__.A&#x27;&gt;, &#x27;古一&#x27;)</span><br><span class="line">我是参数kwargs &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">调用init方法</span><br><span class="line">&lt;__main__.A object at <span class="number">0x00000280B925C520</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，实例对象<code>a</code>时，自动先调用<strong>__new__</strong>方法，由它去创建对象并且由<code>*args</code>, <code>**kwargs</code>来接收创建对象时的参数，第二步，对象创建好后，自动调用<strong>__init__</strong>方法，由它来完成实例对象的属性初始化操作。因此，由<strong>__new__</strong>和<strong>__init__</strong>组成的构造器，完成了对象的创建和初始化。</p><p>前面说到最好不要重写<strong>__new__</strong>方法，但在做<strong>单例模式</strong>时，我们会这么做。</p><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p><strong>单例模式（Singleton Pattern）</strong>是软件设计中的一种常用设计模式，目的主要是使某个类只存在一个实例（节约内存），比如在我们自动化测试框架中，像日志模块和数据库操作等模块，这两个操作类中，其实我们只需要实例一个日志输出对象和数据库操作对象即可，这种情况，我们即可采用单例。</p><p>具体实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>:</span></span><br><span class="line">    __obj = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 如果该类不存在对象，则创建一个对象</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls.__obj:</span><br><span class="line">            cls.__obj = super().__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls.__obj</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果该类已创建过对象，则返回上一个对象</span></span><br><span class="line">            <span class="keyword">return</span> cls.__obj</span><br><span class="line"></span><br><span class="line">a = Singleton()</span><br><span class="line">b = Singleton()</span><br><span class="line">c = Singleton()</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line">print(id(c))</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="number">1537050624832</span></span><br><span class="line"><span class="number">1537050624832</span></span><br><span class="line"><span class="number">1537050624832</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在创建对象会自动调用<strong>__new__</strong>方法，那么我们则可以通过重写<strong>__new__</strong>的方式，来限制一个类的对象创建。定义一个类属性<code>__obj</code>，如果该类没有创建过对象，那么就正常创建这个对象，并把这个对象赋值给类属性<code>__obj</code>，如果创建过对象，那么直接返回<code>__obj</code>，即之前创建的对象，所以最后可以看到，这个类创建的对象id都是一样的，即是同一个对象。</p><p>**ps:**通过装饰器的方式，也可以实现单例模式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="comment"># 创建一个字典来存储类和对象的映射关系</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 如果dic中有key为cls的类，则直接返回其对象</span></span><br><span class="line">        <span class="keyword">if</span> dic.get(cls):</span><br><span class="line">            <span class="keyword">return</span> dic[cls]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 如果dic中没有key为cls的类，那么将cls和其对象cls()放到dic中，并返回该对象</span></span><br><span class="line">            dic[cls] = cls(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> dic[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">b = A()</span><br><span class="line">c = A()</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line">print(id(c))</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="number">2412994972400</span></span><br><span class="line"><span class="number">2412994972400</span></span><br><span class="line"><span class="number">2412994972400</span></span><br></pre></td></tr></table></figure><p>还有更多的单例实现方式，可以参考<a href="%5Bhttps://www.cnblogs.com/huchong/p/8244279.html%5D">听风大佬的博文</a>。</p><h4 id="析构器：-del"><a href="#析构器：-del" class="headerlink" title="析构器：__del__"></a>析构器：__del__</h4><p>python中通过<strong>__del__</strong>就是一个析构函数了，当对象被销毁时，会调用他本身的<strong>析构函数</strong>，另外当对象在某个作用域中调用完毕，在跳出其作用域的同时析构函数也会被调用一次，这样可以用来释放内存空间。</p><blockquote><p>析构函数(destructor) 与构造函数相反，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，delete会自动调用析构函数后释放内存）。</p></blockquote><p>简单来说，就是擦屁股的，这个对象删除不用了，ok，我帮你善后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我来善后！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(<span class="string">&#x27;对象a在该作用域中调用完毕&#x27;</span>) <span class="comment"># 对象a在该作用域中调用完成后，立即调用__del__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;对象a在该作用域中调用完毕&#x27;</span></span><br><span class="line"><span class="string">&#x27;我来善后！&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我来善后！&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">del</span> a <span class="comment"># 删除对象a后，立即调用__del__</span></span><br><span class="line">print(<span class="string">&#x27;对象a没了&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="string">&#x27;我来善后！</span></span><br><span class="line"><span class="string">&#x27;</span>对象a在该作用域中调用完毕<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="enter-和-exit"><a href="#enter-和-exit" class="headerlink" title="__enter__和__exit__"></a>__enter__和__exit__</h3><p>在平常操作文件时，通常需要先打开文件、操作读写、再关闭文件，而当使用<code>with</code> 关键字去操作文件时，却可以自动关闭文件，这是为什么呢？why？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一：</span></span><br><span class="line">f = open(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 方法二：</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这背后的原理其实就是：<strong>上下文管理器</strong>。（上下文管理器具体原理看这篇）</p><p>而实现上下文管理器的方法之一，涉及到两个魔术方法：<strong>__enter__</strong>和<strong>__exit__</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我要进来了&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;我要出去了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Demo(): <span class="comment"># Demo()即为上下文管理器</span></span><br><span class="line">    print(<span class="string">&#x27;我进来了&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">我要进来了</span><br><span class="line">我进来了</span><br><span class="line">我要出去了</span><br></pre></td></tr></table></figure><p>如上所示，<code>Demo</code>实现了<code>__enter__</code>和<code>__exit__</code>这两个上下文管理器协议，当Demo调用/实例化的时候，则创建了上下文管理器<code>Demo</code>。</p><p>当上下文管理器遇到<code>with</code>关键字，上下文管理器就会被激活，先自动调用<code>__enter__</code>，然后进入运行时上下文环境，执行<code>with_body</code>中的语句，执行完成后，自动调用<code>__exit__</code>。其实这里的<code>__enter__</code>和<code>__exit__</code>就类似于我们测试中的<strong>前置</strong>和<strong>后置</strong>。</p><p>通常，<code>with</code>会和<code>as</code>一起使用，当有<code>as</code>从句时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;执行前置条件&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;执行后置条件&#x27;</span>)</span><br><span class="line">        print(exc_type)</span><br><span class="line">        print(exc_val)</span><br><span class="line">        print(exc_tb)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">a, b</span>):</span></span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line"><span class="keyword">with</span> Demo() <span class="keyword">as</span> x:</span><br><span class="line">    print(x.count(<span class="number">4</span>,<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">执行前置条件</span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">执行后置条件</span><br></pre></td></tr></table></figure><p>在执行<code>__enter__</code>方法后，会返回自身或另一个与运行时上下文相关的对象（此例返回了Demo对象），然后赋值给变量<code>x</code>，在上下文环境中，实例对象<code>x</code>执行了<code>count</code>方法。</p><p>此外，在上面的例子中，应该能注意到，我们分别打印了<code>__exit__</code> 中的三个参数：<code>exc_type</code>，<code>exc_val</code>， <code>exc_tb</code>，但是打印结果却都为<code>None</code>，why？</p><p>首先，这三个参数代表的含义为：</p><ul><li>exc_type: 异常类型</li><li>exc_val:异常值</li><li>exc_tb:异常的溯源信息</li></ul><p>当在执行<code>with_body</code>中的语句时，若出现了异常，则会自动执行<code>__exit__</code> 方法，并且将异常信息分别对应这三个参数，传递进<code>__exit__</code> 方法中进行处理。</p><p>我们用上面的例子，修改一下<code>count</code>的参数，构造一个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Demo() <span class="keyword">as</span> x:</span><br><span class="line">    print(x.count(<span class="number">1</span>,<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>此时的运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">执行前置条件</span><br><span class="line">&lt;class &#39;ZeroDivisionError&#39;&gt;</span><br><span class="line">division by zero</span><br><span class="line">&lt;traceback object at 0x00000231755FACC0&gt;</span><br><span class="line">执行后置条件</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 34, in &lt;module&gt;</span><br><span class="line">    print(f.count(1,0))</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 15, in count</span><br><span class="line">    return a &#x2F; b</span><br><span class="line">ZeroDivisionError: division by zero</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，<code>with</code>代码块中的代码出现了异常后，立即触发了<code>__exit__</code>方法捕捉到这个异常，并分别打印了异常的类型、值、溯源信息，然后抛出了异常。</p><p>需要注意的是，如果<code>__exit__</code> 方法中有<code>return True</code>，那么该方法则不会抛出异常。</p><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><p>先抛一个问题：为什么<code>str(123)</code>打印出来会是字符串<code>&quot;123&quot;</code>呢？</p><p>先不忙解释，我们先看如果打印一个类的实例对象，会是什么呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Demo()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">&lt;__main__.Demo object at <span class="number">0x0000019C0B789070</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，打印结果是<code>a</code>的对象信息和内存地址。其实通过查看<code>str()</code>源码会发现，<code>str</code>其实是一个类，所有的字符串都是它的实例对象，那么为什么同样是类，我们自定义类的实例对象的打印结果却不一样呢？原因就在于<code>__str__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">str</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    str(object=&#x27;&#x27;) -&gt; str</span></span><br><span class="line"><span class="string">    str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Create a new string object from the given object. If encoding or</span></span><br><span class="line"><span class="string">    errors is specified, then the object must expose a data buffer</span></span><br><span class="line"><span class="string">    that will be decoded using the given encoding and error handler.</span></span><br><span class="line"><span class="string">    Otherwise, returns the result of object.__str__() (if defined)</span></span><br><span class="line"><span class="string">    or repr(object).</span></span><br><span class="line"><span class="string">    encoding defaults to sys.getdefaultencoding().</span></span><br><span class="line"><span class="string">    errors defaults to &#x27;strict&#x27;.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="string">&#x27;&#x27;</span>, encoding=None, errors=<span class="string">&#x27;strict&#x27;</span></span>):</span></span><br><span class="line">        <span class="comment"># known special case of str.__init__</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        str(object=&#x27;&#x27;) -&gt; str</span></span><br><span class="line"><span class="string">        str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Create a new string object from the given object. If encoding or</span></span><br><span class="line"><span class="string">        errors is specified, then the object must expose a data buffer</span></span><br><span class="line"><span class="string">        that will be decoded using the given encoding and error handler.</span></span><br><span class="line"><span class="string">        Otherwise, returns the result of object.__str__() (if defined)</span></span><br><span class="line"><span class="string">        or repr(object).</span></span><br><span class="line"><span class="string">        encoding defaults to sys.getdefaultencoding().</span></span><br><span class="line"><span class="string">        errors defaults to &#x27;strict&#x27;.</span></span><br><span class="line"><span class="string">        # (copied from class doc)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return str(self). &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> ...............</span><br></pre></td></tr></table></figure><p><code>__str__</code>方法可以自定义实例对象的打印结果为指定的字符串，这里<code>str()</code> 的实例对象返回的是<code>Return str(self)</code>，即返回的对象本身，所以，这就是为什么<code>str(123)</code>打印出来会是字符串<code>&quot;123&quot;</code>。</p><p>我们也可以来自定义试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, price</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;self.name&#125;</span>的价格是：<span class="subst">&#123;self.price&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">benz = Car(<span class="string">&#x27;Benz&#x27;</span>, <span class="string">&#x27;40w&#x27;</span>)</span><br><span class="line">audi = Car(<span class="string">&#x27;Audi&#x27;</span>, <span class="string">&#x27;35w&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(benz) <span class="comment"># 输出：Benz的价格是：40w</span></span><br><span class="line">print(audi) <span class="comment"># 输出：Audi的价格是：35w</span></span><br></pre></td></tr></table></figure><p>同理，<code>int()</code>、<code>bool()</code>等其实也是类似的原理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">int</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    int([x]) -&gt; integer</span></span><br><span class="line"><span class="string">    int(x, base=10) -&gt; integer</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Convert a number or string to an integer, or return 0 if no arguments</span></span><br><span class="line"><span class="string">    are given.  If x is a number, return x.__int__().  For floating point</span></span><br><span class="line"><span class="string">    numbers, this truncates towards zero.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    If x is not a number or if base is given, then x must be a string,</span></span><br><span class="line"><span class="string">    bytes, or bytearray instance representing an integer literal in the</span></span><br><span class="line"><span class="string">    given base.  The literal can be preceded by &#x27;+&#x27; or &#x27;-&#x27; and be surrounded</span></span><br><span class="line"><span class="string">    by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.</span></span><br><span class="line"><span class="string">    Base 0 means to interpret the base from the string as an integer literal.</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; int(&#x27;0b100&#x27;, base=0)</span></span><br><span class="line"><span class="string">    4</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__int__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; int(self) &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">  ...........</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">bool</span>(<span class="params">int</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    bool(x) -&gt; bool</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns True when the argument x is true, False otherwise.</span></span><br><span class="line"><span class="string">    The builtins True and False are the only two instances of the class bool.</span></span><br><span class="line"><span class="string">    The class bool is a subclass of the class int, and cannot be subclassed.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__and__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return self&amp;value. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__or__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; Return self|value. &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">   .........</span><br></pre></td></tr></table></figure><blockquote><p>python自2.2以后，对类和类型进行了统一，做法就是将int()、float()、str()、list()、tuple()这些BIF转换为<strong>工厂函数</strong>，所谓工厂函数，其实就是一个类对象，当你调用他们的时候，事实上就是创建一个相应的实例对象。</p></blockquote><h3 id="add"><a href="#add" class="headerlink" title="__add__"></a>__add__</h3><p><code>&quot;hello,&quot; + &quot;world&quot;</code>字符串为什么可以拼接成<code>&quot;hello,world&quot;</code>?</p><p><code>1+1</code>为什么可以等于整型相加为什么可以等于<code>2</code>?</p><p><code>[1,2,3] + [&quot;a&quot;,&quot;b&quot;]</code>列表相加为什么可以合并为<code>[1,2,3,&quot;a&quot;,&quot;b&quot;]</code>?</p><p><code>&#123;&quot;a&quot;:1&#125; + &#123;&quot;b&quot;:2&#125;</code>字典又为什么不能直接相加合并呢？</p><p>原因是可以相加的类里都有<code>__add__</code>方法，而字典没有该方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Return self+value. &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>那为什么有这个方法就能让同类型的对象相加呢？</p><p>因为<code>__add__</code>方法定义了对象相加的逻辑和返回值，当使用<code>+</code>操作时，将会触发<code>__add__()</code>方法。</p><p>直接上例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man = Person(<span class="number">22</span>)</span><br><span class="line">woman = Person(<span class="number">20</span>)</span><br><span class="line">print(man+woman)</span><br></pre></td></tr></table></figure><p>这里<code>Person</code>类中并没有定义对象相加的方法，此时直接相加就会报错，提示不支持该操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 8, in &lt;module&gt;</span><br><span class="line">    print(man+woman)</span><br><span class="line">TypeError: unsupported operand type(s) for +: &#39;Person&#39; and &#39;Person&#39;</span><br></pre></td></tr></table></figure><p>加上<code>__add__</code>后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.age + other.age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man = Person(<span class="number">22</span>)</span><br><span class="line">woman = Person(<span class="number">20</span>)</span><br><span class="line">print(man + woman)</span><br><span class="line"><span class="comment"># 输出结果： 42</span></span><br></pre></td></tr></table></figure><p><code>__add__</code>方法中的参数<code>self</code>和<code>other</code>分别指<code>Person</code>的不同实例对象，这里<code>self</code>即对象<code>man</code>，<code>other</code>即对象<code>woman</code>。配合上文提到的<code>__str__</code>，还可以自定义<code>+</code>的打印结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, age</span>):</span></span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;两人年龄之和为:<span class="subst">&#123;self.age&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Person(self.age + other.age)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">man = Person(<span class="number">22</span>)</span><br><span class="line">woman = Person(<span class="number">20</span>)</span><br><span class="line">print(man + woman)</span><br><span class="line"><span class="comment"># 输出结果：两人年龄之和为:42</span></span><br></pre></td></tr></table></figure><p>这里只提到了<code>+</code>的魔术方法，其实其他的运算符也都有对应的魔术方法，原理也差不多，本文就不再赘述。</p><p>附上其它运算符对应魔术方法：</p><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/ae86sen/mypic2/%E8%BF%90%E7%AE%97%E7%AC%A6.png"></p><h3 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h3><p>众所周知，python是一门动态语言，所谓动态就是运行代码时可以根据某些条件改变自身结构，例如创建一个类的实例对象，可以给该实例绑定任意的属性和方法。</p><p>绑定属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.name = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">print(a.name) <span class="comment"># 输出：python</span></span><br></pre></td></tr></table></figure><p>绑定方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_age</span>(<span class="params">self, age</span>):</span></span><br><span class="line">    self.age = age</span><br><span class="line"></span><br><span class="line">a.set_age = MethodType(set_age, a) <span class="comment"># 将setage()方法绑定为对象a的方法</span></span><br><span class="line">a.set_age(<span class="number">18</span>)</span><br><span class="line">print(a.age) <span class="comment"># 输出18</span></span><br></pre></td></tr></table></figure><p>此外，每个类的实例对象都会被分配一个<code>__dict__</code>属性，它会维护该实例的所有属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name,age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&#x27;古一&#x27;</span>,<span class="number">18</span>)</span><br><span class="line">print(a.__dict__) </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;古一&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure><p>如果我们再实例一个对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b = A(<span class="string">&#x27;古二&#x27;</span>,<span class="number">19</span>)</span><br><span class="line">print(b.__dict__) </span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;古二&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">19</span>&#125;</span><br></pre></td></tr></table></figure><p>由此可见，类的每次实例化，都会为其对象分配一个<code>__dict__</code>属性，那么试想，如果需要创建大量实例，这个<code>__dict__</code>就会有点浪费内存了。</p><p>所以python也是提供了一种解决方案，就是在类中定义<code>__slots__</code>属性。</p><p><code>__slots__</code>一是可以限制实例能添加的属性，二是阻止类实例化时分配<code>__dict__</code>属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>] </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">&#x27;古一&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">a.gender = <span class="string">&#x27;male&#x27;</span></span><br><span class="line">print(a.gender)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 65, in &lt;module&gt;</span><br><span class="line">    a.gender &#x3D; &#39;male&#39;</span><br><span class="line">AttributeError: &#39;A&#39; object has no attribute &#39;gender&#39;</span><br></pre></td></tr></table></figure><p>报错提示<code>A</code> 对象没有<code>gender</code>这个属性，因为<code>__slots__</code>限制了这个类的所有实例对象只能有<code>name</code>、<code>age</code>这两个属性，不能再添加任何属性。</p><p>另外，<code>A</code>的实例对象也不再有<code>__dict__</code>属性了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a.__dict__)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 66, in &lt;module&gt;</span><br><span class="line">    print(a.__dict__)</span><br><span class="line">AttributeError: &#39;A&#39; object has no attribute &#39;__dict__&#39;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li><code>__slots__</code>仅对当前类起作用，对继承的子类不起作用</li><li>在子类中定义<code>__slots__</code>，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code></li></ul><p>说了这么多，有啥实际应用呢？</p><p>在接口自动化测试中，有个场景是需要验证查询日志的返回结果是否跟查询条件一致，比如返回了一组这样的json数据：<img src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/ae86sen/mypic2/json.png"></p><p>即我需要校验其中每个字典中某些字段的值和查询条件一致，那么我该怎么处理呢？</p><p>第一个方法很简单，直接用<code>jsonpath</code>提取查询字段，然后遍历比较就行，但是日志的数量通常是上万条的，这时候<code>jsonpath</code>的性能就不太行。</p><p>第二个方法，就是自己定义一个逻辑实现。我们可以看到，这样一组json数据中，列表中嵌套了许多字典，每个字典的结构其实都一样，<code>key</code>都是一样的，只是<code>value</code>不一定一样，那么，我们可以封装一个校验json的类，把每个字典都当做一个实例对象，里面的<code>key</code>就是实例属性，<code>value</code>就是实例属性值，然后我们还可以顶一个<code>is_validated</code>方法来对做相关的校验，比如这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">&#x27;happenTime&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;appName&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, json_data</span>):</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> json_data.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">in</span> self.__slots__:</span><br><span class="line">                setattr(self, k, v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_validated</span>(<span class="params">self,expr</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>另外有些<code>key</code> 对我们来说，是不需要的，我们只需要保留查询条件字段即可（比如我们的查询字段为<code>happenTime</code>、 <code>type</code>、 <code>appName</code>，那么我们就只需要保留这三个字段），因此我们可以设置<code>__slots__</code>来限制只保留我们需要的字段，相当于一个白名单，另外，也可以阻止<code>__dict__</code>的生成来节约内存。</p><p>这个方法的好处是，代码复用性会更强，扩展性也更强，如果下一次又加了几个新字段，那么继承一下，那么第一个版本和第二个版本分别是属性隔离、接口隔离的，也符合面向对象的开闭原则。</p><p>但是，目前这个方法的运行速度还不够快，还需要优化，暂时还没想到更好的方法，害。</p><h3 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h3><p>python的自定义属性访问涉及到四个魔术方法，分别是：<code>__getattribute__</code>、<code>__getattr__</code>、<code>__setattr__</code>和<code>__delattr__</code>。</p><h4 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line">print(a.x)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">调用__getattribute__</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure><p>可以看到，当我们在一个类中定义了<code>__getattribute__</code>方法，在访问对象属性的时候，会去调用这个方法，但是这里返回的结果却是<code>None</code>，这是因为我们重写了父类的<code>__getattribute__</code>方法，它无法完成返回对应属性值的操作。</p><p>父类object中的<code>__getattribute__</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, *args, **kwargs</span>):</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Return getattr(self, name). &quot;&quot;&quot;</span>  <span class="comment"># 返回属性值</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：虽然看源码我们知道该方法其实就是Return getattr(self, name)，但是我们重写的时候绝对不能这么写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> self.item <span class="comment"># 相当于self.__getattribute__(item)</span></span><br></pre></td></tr></table></figure><p>这样将会陷入无限递归~</p><p>因此我们需要调用父类的该方法，来实现返回属性值的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;item:<span class="subst">&#123;item&#125;</span>&#x27;</span>)         <span class="comment"># item即属性名</span></span><br><span class="line">        <span class="keyword">return</span> super().__getattribute__(item)</span><br><span class="line"> </span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line">print(a.x)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">调用__getattribute__</span><br><span class="line">item:x</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p><code>a.x</code>等价于<code>a.__getattribute__(x)</code>。</p><h4 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h4><p>接上面的例子，当访问一个存在的属性时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;item:<span class="subst">&#123;item&#125;</span>&#x27;</span>)         <span class="comment"># item即属性名</span></span><br><span class="line">        <span class="keyword">return</span> super().__getattribute__(item)</span><br><span class="line"> </span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line">print(a.y)</span><br></pre></td></tr></table></figure><p>此时会直接报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用__getattribute__</span><br><span class="line">item:y</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 16, in &lt;module&gt;</span><br><span class="line">    print(a.name)</span><br><span class="line">  File &quot;C:\Users\ancient\demo.py&quot;, line 8, in __getattribute__</span><br><span class="line">    return super().__getattribute__(item)</span><br><span class="line">AttributeError: &#39;A&#39; object has no attribute &#39;y&#39;</span><br></pre></td></tr></table></figure><p>如果我们在这个类中定义一个<code>__getattr__</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;item:<span class="subst">&#123;item&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattr__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line">print(a.y)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">调用__getattribute__</span><br><span class="line">item:name</span><br><span class="line">调用__getattr__</span><br><span class="line">None</span><br></pre></td></tr></table></figure><p>可以发现，当访问属性时，会先调用<code>__getattribute__</code>，如果这个属性存在，就返回属性值，如果这个属性不存在（发生AttributeError错误），将会触发<code>__getattr__</code>，这个方法会捕获异常。</p><p>其实可以总结出，访问属性时，属性的查找过程如下（如<code>print(a.attr)</code>）：</p><p>1、首先会在对象的实例属性中寻找，未找到则执行第二步</p><p>2、在对象所在的类中查找类属性，未找到则执行第三步</p><p>3、到对象的继承链上寻找，未找到则只需第四步</p><p>4、最后调用<code>__getattr__</code>方法，如果该属性还是没有找到且没有定义<code>__getattr__</code>方法，那么就会抛出<code>AttributeError</code>，终止查找。</p><h4 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a>__setattr__</h4><p>这个很好理解，就是在给对象定义属性时，就会触发<code>__setattr__</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattribute__&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;item:<span class="subst">&#123;item&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__getattribute__(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__getattr__&#x27;</span>)</span><br><span class="line">        self.item = <span class="number">123</span></span><br><span class="line">        <span class="keyword">return</span> self.item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        print(<span class="string">f&#x27;key:<span class="subst">&#123;key&#125;</span>&#x27;</span>)</span><br><span class="line">        print(<span class="string">f&#x27;value:<span class="subst">&#123;value&#125;</span>&#x27;</span>)</span><br><span class="line">        super().__setattr__(key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line">a.y = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">setattr(a, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;java&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">key:x</span><br><span class="line">value:<span class="number">123</span></span><br><span class="line">key:y</span><br><span class="line">value:python</span><br><span class="line">key:z</span><br><span class="line">value:java</span><br></pre></td></tr></table></figure><p>可以看到三种定义对象属性的方式，不管是哪一种，都会触发<code>__setattr__</code>。</p><p>此外，这里重写<code>__setattr__</code>方法时，也必须调用父类<code>__setattr__</code>，否则属性不会真正设置成功。</p><h4 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a>__delattr__</h4><p>很明显，最后一个方法就是在删除对象属性时触发的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__delattr__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">del</span> a.x</span><br><span class="line">print(a.x)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">调用__delattr__</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>值得注意的是，当重写了<code>__delattr__</code>时，如果没有调用父类的<code>__delattr__</code>，其实属性是不会被删除的。要想删除，就必须调用父类方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">      print(<span class="string">&#x27;调用__delattr__&#x27;</span>)</span><br><span class="line">      super().__delattr__(item)</span><br></pre></td></tr></table></figure><h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4><p>上面说了那么多，结合一个小例子，来看看这几个魔术方法的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">定义一个Students类：</span><br><span class="line">属性：</span><br><span class="line">    name: 属性值只能是字符串</span><br><span class="line">    age:属性值只能是int</span><br><span class="line">    grade:属性值只能是dict类型</span><br><span class="line">    </span><br><span class="line">name属性不能被删除</span><br><span class="line">grade属性如果没有添加，则返回None</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(value,str):</span><br><span class="line">                super().__setattr__(key,value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;name属性只能是str类型&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> key == <span class="string">&#x27;age&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(value,int):</span><br><span class="line">                super().__setattr__(key,value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;age属性只能是int类型&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> key == <span class="string">&#x27;grade&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> isinstance(value,dict):</span><br><span class="line">                super().__setattr__(key,value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;grade属性只能是dict类型&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&#x27;name&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(<span class="string">&#x27;name属性不能被删除&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            super().__delattr__(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">&#x27;grade&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> super().__getattribute__(item)</span><br><span class="line">a = Students()</span><br><span class="line">a.name = <span class="number">123</span> <span class="comment"># 报错，提示name属性只能是str类型</span></span><br><span class="line">a.age = <span class="string">&#x27;12&#x27;</span> <span class="comment"># 报错，提示age属性只能是int类型</span></span><br><span class="line">print(a.grade) <span class="comment"># 返回None</span></span><br><span class="line"><span class="keyword">del</span> a.name <span class="comment"># 报错，提示name属性不能被删除</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上文中总结了一些常用的魔术方法，所谓魔术方法，我个人理解其实就像LOL中每个英雄的<strong>被动技能</strong>，当我们给一个类定义了一些魔术方法，就相当于赋予了它一个被动技能，这个被动技能会在特定的情况下被自动触发，从而使对象变得更加灵活强大，实现一些或高级或复杂的功能，是真正的<strong>黑魔法</strong>。</p><p>当然，python中的魔术方法远不止上面所总结的，下面附上python中的魔术方法大全以供查阅。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p><strong>魔术方法大全</strong></p><table><thead><tr><th><strong>魔法方法</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>基本的魔法方法</strong></td><td></td></tr><tr><td><strong><strong>new</strong>(cls[, …])</strong></td><td>__new__是在一个对象实例化的时候所调用的第一个方法</td></tr><tr><td><strong><strong>init</strong>(self[, …])</strong></td><td>构造器，当一个实例被创建的时候调用的初始化方法</td></tr><tr><td><strong><strong>del</strong>(self)</strong></td><td>析构器，当一个实例被销毁的时候调用的方法</td></tr><tr><td><strong><strong>call</strong>(self[, args…])</strong></td><td>允许一个类的实例像函数一样被调用：x(a, b) 调用 x.<strong>call</strong>(a, b)</td></tr><tr><td><strong><strong>len</strong>(self)</strong></td><td>定义当被 len() 调用时的行为</td></tr><tr><td><strong><strong>repr</strong>(self)</strong></td><td>定义当被 repr() 调用时的行为</td></tr><tr><td><strong><strong>str</strong>(self)</strong></td><td>定义当被 str() 调用时的行为</td></tr><tr><td><strong><strong>bytes</strong>(self)</strong></td><td>定义当被 bytes() 调用时的行为</td></tr><tr><td><strong><strong>hash</strong>(self)</strong></td><td>定义当被 hash() 调用时的行为</td></tr><tr><td><strong><strong>bool</strong>(self)</strong></td><td>定义当被 bool() 调用时的行为，应该返回 True 或 False</td></tr><tr><td><strong><strong>format</strong>(self, format_spec)</strong></td><td>定义当被 format() 调用时的行为</td></tr><tr><td><strong>有关属性</strong></td><td></td></tr><tr><td><strong><strong>getattr</strong>(self, name)</strong></td><td>定义当用户试图获取一个不存在的属性时的行为</td></tr><tr><td><strong><strong>getattribute</strong>(self, name)</strong></td><td>定义当该类的属性被访问时的行为</td></tr><tr><td><strong><strong>setattr</strong>(self, name, value)</strong></td><td>定义当一个属性被设置时的行为</td></tr><tr><td><strong><strong>delattr</strong>(self, name)</strong></td><td>定义当一个属性被删除时的行为</td></tr><tr><td><strong><strong>dir</strong>(self)</strong></td><td>定义当 dir() 被调用时的行为</td></tr><tr><td><strong><strong>get</strong>(self, instance, owner)</strong></td><td>定义当描述符的值被取得时的行为</td></tr><tr><td><strong><strong>set</strong>(self, instance, value)</strong></td><td>定义当描述符的值被改变时的行为</td></tr><tr><td><strong><strong>delete</strong>(self, instance)</strong></td><td>定义当描述符的值被删除时的行为</td></tr><tr><td><strong>比较操作符</strong></td><td></td></tr><tr><td><strong><strong>lt</strong>(self, other)</strong></td><td>定义小于号的行为：x &lt; y 调用 x.<strong>lt</strong>(y)</td></tr><tr><td><strong><strong>le</strong>(self, other)</strong></td><td>定义小于等于号的行为：x &lt;= y 调用 x.<strong>le</strong>(y)</td></tr><tr><td><strong><strong>eq</strong>(self, other)</strong></td><td>定义等于号的行为：x == y 调用 x.<strong>eq</strong>(y)</td></tr><tr><td><strong><strong>ne</strong>(self, other)</strong></td><td>定义不等号的行为：x != y 调用 x.<strong>ne</strong>(y)</td></tr><tr><td><strong><strong>gt</strong>(self, other)</strong></td><td>定义大于号的行为：x &gt; y 调用 x.<strong>gt</strong>(y)</td></tr><tr><td><strong><strong>ge</strong>(self, other)</strong></td><td>定义大于等于号的行为：x &gt;= y 调用 x.<strong>ge</strong>(y)</td></tr><tr><td><strong>算数运算符</strong></td><td></td></tr><tr><td><strong><strong>add</strong>(self, other)</strong></td><td>定义加法的行为：+</td></tr><tr><td><strong><strong>sub</strong>(self, other)</strong></td><td>定义减法的行为：-</td></tr><tr><td><strong><strong>mul</strong>(self, other)</strong></td><td>定义乘法的行为：*</td></tr><tr><td><strong><strong>truediv</strong>(self, other)</strong></td><td>定义真除法的行为：/</td></tr><tr><td><strong><strong>floordiv</strong>(self, other)</strong></td><td>定义整数除法的行为：//</td></tr><tr><td><strong><strong>mod</strong>(self, other)</strong></td><td>定义取模算法的行为：%</td></tr><tr><td><strong><strong>divmod</strong>(self, other)</strong></td><td>定义当被 divmod() 调用时的行为</td></tr><tr><td><strong><strong>pow</strong>(self, other[, modulo])</strong></td><td>定义当被 power() 调用或 ** 运算时的行为</td></tr><tr><td><strong><strong>lshift</strong>(self, other)</strong></td><td>定义按位左移位的行为：&lt;&lt;</td></tr><tr><td><strong><strong>rshift</strong>(self, other)</strong></td><td>定义按位右移位的行为：&gt;&gt;</td></tr><tr><td><strong><strong>and</strong>(self, other)</strong></td><td>定义按位与操作的行为：&amp;</td></tr><tr><td><strong><strong>xor</strong>(self, other)</strong></td><td>定义按位异或操作的行为：^</td></tr><tr><td><strong><strong>or</strong>(self, other)</strong></td><td>定义按位或操作的行为：|</td></tr><tr><td><strong>反运算</strong></td><td></td></tr><tr><td><strong><strong>radd</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rsub</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rmul</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rtruediv</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rfloordiv</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rmod</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rdivmod</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rpow</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rlshift</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rrshift</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rand</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>rxor</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong><strong>ror</strong>(self, other)</strong></td><td>（与上方相同，当左操作数不支持相应的操作时被调用）</td></tr><tr><td><strong>增量赋值运算</strong></td><td></td></tr><tr><td><strong><strong>iadd</strong>(self, other)</strong></td><td>定义赋值加法的行为：+=</td></tr><tr><td><strong><strong>isub</strong>(self, other)</strong></td><td>定义赋值减法的行为：-=</td></tr><tr><td><strong><strong>imul</strong>(self, other)</strong></td><td>定义赋值乘法的行为：*=</td></tr><tr><td><strong><strong>itruediv</strong>(self, other)</strong></td><td>定义赋值真除法的行为：/=</td></tr><tr><td><strong><strong>ifloordiv</strong>(self, other)</strong></td><td>定义赋值整数除法的行为：//=</td></tr><tr><td><strong><strong>imod</strong>(self, other)</strong></td><td>定义赋值取模算法的行为：%=</td></tr><tr><td><strong><strong>ipow</strong>(self, other[, modulo])</strong></td><td>定义赋值幂运算的行为：**=</td></tr><tr><td><strong><strong>ilshift</strong>(self, other)</strong></td><td>定义赋值按位左移位的行为：&lt;&lt;=</td></tr><tr><td><strong><strong>irshift</strong>(self, other)</strong></td><td>定义赋值按位右移位的行为：&gt;&gt;=</td></tr><tr><td><strong><strong>iand</strong>(self, other)</strong></td><td>定义赋值按位与操作的行为：&amp;=</td></tr><tr><td><strong><strong>ixor</strong>(self, other)</strong></td><td>定义赋值按位异或操作的行为：^=</td></tr><tr><td><strong><strong>ior</strong>(self, other)</strong></td><td>定义赋值按位或操作的行为：|=</td></tr><tr><td><strong>一元操作符</strong></td><td></td></tr><tr><td><strong><strong>pos</strong>(self)</strong></td><td>定义正号的行为：+x</td></tr><tr><td><strong><strong>neg</strong>(self)</strong></td><td>定义负号的行为：-x</td></tr><tr><td><strong><strong>abs</strong>(self)</strong></td><td>定义当被 abs() 调用时的行为</td></tr><tr><td><strong><strong>invert</strong>(self)</strong></td><td>定义按位求反的行为：~x</td></tr><tr><td><strong>类型转换</strong></td><td></td></tr><tr><td><strong><strong>complex</strong>(self)</strong></td><td>定义当被 complex() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong><strong>int</strong>(self)</strong></td><td>定义当被 int() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong><strong>float</strong>(self)</strong></td><td>定义当被 float() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong><strong>round</strong>(self[, n])</strong></td><td>定义当被 round() 调用时的行为（需要返回恰当的值）</td></tr><tr><td><strong><strong>index</strong>(self)</strong></td><td>1. 当对象是被应用在切片表达式中时，实现整形强制转换 2. 如果你定义了一个可能在切片时用到的定制的数值型,你应该定义 <strong>index</strong> 3. 如果 <strong>index</strong> 被定义，则 <strong>int</strong> 也需要被定义，且返回相同的值</td></tr><tr><td></td><td>上下文管理（with 语句）</td></tr><tr><td><strong><strong>enter</strong>(self)</strong></td><td>1. 定义当使用 with 语句时的初始化行为 2. <strong>enter</strong> 的返回值被 with 语句的目标或者 as 后的名字绑定</td></tr><tr><td><strong><strong>exit</strong>(self, exc_type, exc_value, traceback)</strong></td><td>1. 定义当一个代码块被执行或者终止后上下文管理器应该做什么 2. 一般被用来处理异常，清除工作或者做一些代码块执行完毕之后的日常工作</td></tr><tr><td><strong>容器类型</strong></td><td></td></tr><tr><td><strong><strong>len</strong>(self)</strong></td><td>定义当被 len() 调用时的行为（返回容器中元素的个数）</td></tr><tr><td><strong><strong>getitem</strong>(self, key)</strong></td><td>定义获取容器中指定元素的行为，相当于 self[key]</td></tr><tr><td><strong><strong>setitem</strong>(self, key, value)</strong></td><td>定义设置容器中指定元素的行为，相当于 self[key] = value</td></tr><tr><td><strong><strong>delitem</strong>(self, key)</strong></td><td>定义删除容器中指定元素的行为，相当于 del self[key]</td></tr><tr><td><strong><strong>iter</strong>(self)</strong></td><td>定义当迭代容器中的元素的行为</td></tr><tr><td><strong><strong>reversed</strong>(self)</strong></td><td>定义当被 reversed() 调用时的行为</td></tr><tr><td><strong><strong>contains</strong>(self, item)</strong></td><td>定义当使用成员测试运算符（in 或 not in）时的行为</td></tr></tbody></table><p>参考文章：<a href="https://www.cnblogs.com/nmb-musen/p/10861536.html">《python魔术方法大全》</a></p>]]></content>
    
    
    <summary type="html">python中魔术方法总结</summary>
    
    
    
    <category term="总结" scheme="http://ancientone.cf/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://ancientone.cf/tags/python/"/>
    
    <category term="魔术方法" scheme="http://ancientone.cf/tags/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>上下文管理器</title>
    <link href="http://ancientone.cf/posts/65e41272.html"/>
    <id>http://ancientone.cf/posts/65e41272.html</id>
    <published>2020-10-11T17:22:23.000Z</published>
    <updated>2020-12-11T10:41:14.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="何谓上下文管理器"><a href="#何谓上下文管理器" class="headerlink" title="何谓上下文管理器"></a>何谓上下文管理器</h3><p>说到<strong>上下文</strong>，相信大家都还记得，在中学语文考试的阅读理解题上，我们经常会看到“联系上下文，解释xxx的意思”，这里的“上下文”指的是语言环境。</p><p>那么对应到代码中，其实也是一个意思，即<strong>程序所执行的环境状态</strong>。</p><p>那么<strong>管理器</strong>又怎么说呢？在我们写代码的时候，我们会把操作放在一个代码块中（比如读写文件），这样执行代码块时就可以保持一种运行状态，而当离开这个代码块时，就结束当前状态，去执行另一个操作，如果在这个代码块的运行状态还没结束时，此时又“越界”去做了另一个操作，上下文管理器就会做出相应的处理。</p><p>在我们做IO操作时（比如文件读写、数据库连接断开等操作），每一个操作都是会占用系统资源的，而且系统资源有限，如果使用这些资源后却一直不释放，那么久容易造成资源泄露，导致系统运行缓慢，甚至崩溃。</p><p>比如这样一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000000</span>): </span><br><span class="line">    f = open(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;python&#x27;</span>) </span><br></pre></td></tr></table></figure><p>打开<code>test.txt</code>这个文件并写入一句话，执行<code>10000000</code>次，但是每次其实是没有去释放资源的（即关闭文件），这样就很容易造成资源泄露，导致报错<code>OSError</code>。</p><p>而更合理的做法应该是，每次打开写入完成后，就关闭文件去释放资源，所以为了解决这个问题，通过上下文管理器可以帮助我们使用完资源后去自动释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(<span class="string">&#x27;python&#x27;</span>)</span><br></pre></td></tr></table></figure><p>那么我们想要自己实现一个上下文管理器，该怎么做呢？</p><h3 id="实现上下文管理器"><a href="#实现上下文管理器" class="headerlink" title="实现上下文管理器"></a>实现上下文管理器</h3><p>实现上下文管理器的方法，有两种，一种是通过魔术方法实现，一种是基于生成器实现。</p><h4 id="魔术方法实现"><a href="#魔术方法实现" class="headerlink" title="魔术方法实现"></a>魔术方法实现</h4><p>上下文管理器的实现，涉及到<strong>__enter__</strong>和<strong>__exit__</strong>两个魔术方法，我们自己来定义一个<code>HandleFile</code>类，来实现文件打开和自动关闭。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, mode</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__init__&#x27;</span>)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.mode = mode</span><br><span class="line">        self.file = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__enter__&#x27;</span>)</span><br><span class="line">        self.file = open(self.name, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.file</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;调用__exit__&#x27;</span>)</span><br><span class="line">        self.file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> HandleFile(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    print(<span class="string">&#x27;在文件中写入&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;python&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">调用__init__</span><br><span class="line">调用__enter__</span><br><span class="line">在文件中写入</span><br><span class="line">调用__exit__</span><br></pre></td></tr></table></figure><p>通过<code>with</code> 关键字激活上下文管理<code>HandleFile</code>后，<code>HandleFile(&#39;test.txt&#39;, &#39;w&#39;)</code>先初始化完成，然后自动执行<code>__enter__</code> 方法进入上下环境，<code>__enter__</code> 方法的返回值赋值给变量<code>f</code>，<code>f</code>在调用<code>write</code>方法完成写操作后，自动触发<code>__exit__</code>来关闭文件。</p><p>这两个魔术方法的详细使用，可以查看《魔术方法总结》一文中的对应小节，这里不再赘述。</p><h4 id="基于生成器实现"><a href="#基于生成器实现" class="headerlink" title="基于生成器实现"></a>基于生成器实现</h4><p>如果不想通过一个类来实现一个简单的上下文管理器，python提供了一个装饰器<code>contextlib.contextmanager</code>，通过它可以将一个函数变为上下文管理器。</p><p>我们来实现一个和魔术方法等价的上下文管理器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_file</span>(<span class="params">name, mode</span>):</span></span><br><span class="line">    <span class="keyword">try</span>: <span class="comment"># 相当于__enter__</span></span><br><span class="line">        f = open(name, mode)</span><br><span class="line">        <span class="keyword">yield</span> f</span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        print(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>: <span class="comment"># 相当于__exit__</span></span><br><span class="line">        f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> handle_file(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;python666&#x27;</span>)</span><br><span class="line">    print(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line">出错了</span><br></pre></td></tr></table></figure><p>在被装饰的函数中，必须有<code>yiled</code>关键字，<code>yiled</code>之前的代码就相当于<code>__enter__</code>，完成打开文件并将返回值传给<code>f</code>，<code>yiled</code>之后的关键字就相当于<code>__exit__</code>，等<code>with</code>代码块中的代码执行完成后，就去关闭文件。此外，通过<code>try-except</code> 实现了上下管理器的异常处理。所以，这个方法和魔术方法实现的上下文管理器，是完全等价的。</p><h3 id="在工作中的应用"><a href="#在工作中的应用" class="headerlink" title="在工作中的应用"></a>在工作中的应用</h3><h4 id="数据库连接断开"><a href="#数据库连接断开" class="headerlink" title="数据库连接断开"></a>数据库连接断开</h4><p>在做接口自动化时，数据库的连接断开，也可以通过上下文管理器来简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandleMysql</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, hostname, port</span>):</span></span><br><span class="line">        self.hostname = hostname</span><br><span class="line">        self.port = port</span><br><span class="line">        self.connection = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.connection = pymysql.connect(self.hostname, self.port, charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self.connection</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        self.connection.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> HandleMysql(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;80&#x27;</span>) <span class="keyword">as</span> db:</span><br><span class="line">    print(<span class="string">&#x27;执行数据库的增删查改操作&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="allure-step"><a href="#allure-step" class="headerlink" title="allure.step()"></a>allure.step()</h4><p>在<code>allure</code>中提供了一个<code>step()</code>方法，通过这个方法，可以将测试步骤展现在测试报告中。<code>step</code> 有两种用法，一种通过装饰器调用，一种则是通过上下文管理器使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @allure.step(&#x27;step1:注册&#x27;) 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">case_register</span>(<span class="params">self, data</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    注册业务场景</span></span><br><span class="line"><span class="string">    :param data:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">with</span> allure.step(<span class="string">&#x27;step1:注册&#x27;</span>): <span class="comment"># 方法二</span></span><br><span class="line">        data = self.template(data, &#123;<span class="string">&#x27;mobile_phone&#x27;</span>: self.random_phone()&#125;)</span><br><span class="line">        res = self.register_api(**data).json()</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>我们点进<code>step</code>方法查看源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step</span>(<span class="params">title</span>):</span></span><br><span class="line">    <span class="keyword">if</span> callable(title):</span><br><span class="line">        <span class="keyword">return</span> StepContext(title.__name__, &#123;&#125;)(title)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> StepContext(title, &#123;&#125;)</span><br></pre></td></tr></table></figure><p>可以看到返回的是<code>StepContext()</code>对象，继续点进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StepContext</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, title, params</span>):</span></span><br><span class="line">        self.title = title</span><br><span class="line">        self.params = params</span><br><span class="line">        self.uuid = uuid4()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        plugin_manager.hook.start_step(uuid=self.uuid, title=self.title, params=self.params)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span></span><br><span class="line">        plugin_manager.hook.stop_step(uuid=self.uuid, title=self.title, exc_type=exc_type, exc_val=exc_val,</span><br><span class="line">                                      exc_tb=exc_tb)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self, func</span>):</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">impl</span>(<span class="params">*a, **kw</span>):</span></span><br><span class="line">            __tracebackhide__ = <span class="literal">True</span></span><br><span class="line">            params = func_parameters(func, *a, **kw)</span><br><span class="line">            args = list(map(<span class="keyword">lambda</span> x: represent(x), a))</span><br><span class="line">            <span class="keyword">with</span> StepContext(self.title.format(*args, **params), params):</span><br><span class="line">                <span class="keyword">return</span> func(*a, **kw)</span><br><span class="line">        <span class="keyword">return</span> impl</span><br></pre></td></tr></table></figure><p>可以发现，其实它就是通过<code>__enter__</code>和<code>__exit__</code>来实现的上下文管理器。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上下文管理器通常和 with 语句一起使用，大大提高了程序的简洁度和复用率。在文件的打开关闭和数据库的连接断开等场景中，可以确保用过的资源得到迅速释放，使程序安全性更高。</p>]]></content>
    
    
    <summary type="html">上下文管理器使用总结</summary>
    
    
    
    <category term="总结" scheme="http://ancientone.cf/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="python" scheme="http://ancientone.cf/tags/python/"/>
    
    <category term="上下文管理器" scheme="http://ancientone.cf/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>基于docker+grafana+influxdb的性能监控系统搭建</title>
    <link href="http://ancientone.cf/posts/59d444a5.html"/>
    <id>http://ancientone.cf/posts/59d444a5.html</id>
    <published>2020-07-05T11:17:37.000Z</published>
    <updated>2020-11-19T13:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前压测一直用的是jmeter自带的聚合报告来分析结果，但是对tps,qps等性能指标进行页面可视化显示效果不是很好，so，引入了grafana+influxdb，会有一个非常炫酷的可视化页面和全面的视图分析。</p><p>在搭建之前，先简单了解下grafana和influxdb是什么。</p><h2 id="influxdb简介"><a href="#influxdb简介" class="headerlink" title="influxdb简介"></a>influxdb简介</h2><p><a href="https://github.com/influxdata/influxdb">Influx DB</a>是一个开源时间序列数据库。那么问题来了，什么叫时序数据库？想详细了解可以查看这篇<a href="https://www.sohu.com/a/237660940_130419">文章</a>。</p><p><strong>influxdb有三个特性</strong>：</p><ol><li>Time Series （时间序列）：可以使用与时间有关的相关聚合函数</li><li>Metrics（度量）：可以实时对大量数据进行计算</li><li>Eevents（事件）：它支持任意的事件数据</li></ol><p><strong>它的核心概念</strong>（以mysql作为参照）：</p><ol><li>database相当于mysql中的database</li><li>measurement相当于mysql中的表</li><li>point相当于mysql中的行</li><li>tag相当于mysql中的索引，只支持字符串类型</li><li>field相当于mysql中的列，支持多种类型</li><li>retention policy保存策略，这是influxdb特有的属性，rp指定数据在influxdb中的保存时间，时间已过，influxdb会自动清除数据。influxdb不支持修改语句，虽然有删除语句，但是不建议使用</li><li>continuous queries 特色功能之一，相当于定时任务。</li></ol><p><strong>一些基本语法</strong>（其实和mysql差不多，注意table是measurement）：</p><ol><li>create database “db_name” #创建数据库 </li><li>show databases #显示所有的数据库 </li><li>drop database “db_name” #删除数据库 </li><li>use db_name #使用数据库 </li><li>show measurements #显示该数据库中所有的表 </li><li>insert test,host=127.0.0.1,monitor_name=test count=1 #创建表，直接在插入数据的时候指定表名 </li><li>drop measurement “measurement_name”  #删除表 </li><li>select * from access_list  #查询access_list表</li></ol><p><strong><em>它具有的以上特点让其与数据实时监控形成完美契合。成为开发监控系统的首选数据库之一。</em></strong></p><h2 id="grafana简介"><a href="#grafana简介" class="headerlink" title="grafana简介"></a>grafana简介</h2><p><a href="https://github.com/grafana/grafana">grafana</a>是一款采用 go 语言编写的开源应用，主要用于大规模指标数据的可视化展现，是网络架构和应用分析中最流行的<strong>时序数据展示</strong>工具，目前已经支持绝大部分常用的时序数据库。</p><ol><li>面板：包含图形、singlestat 、表、热图、提醒清单，文本、仪表板列表</li><li>仪表板功能：变量（variables）、注释（animation）、文件夹、播放列表、搜索、分享、时间范围、进出口、脚本仪表板，JSON模型等</li><li>数据源：Graphite、Promthus、influxDB、mysql等</li><li>警报：引擎规则、度量、通知</li></ol><p>更多页面详细介绍，可以查看<a href="https://grafana.com/docs/grafana/latest/getting-started">官方文档</a>。</p><p>话不多说，下面我们开始部署~</p><h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p>我们采用方便快速的docker进行部署。</p><h3 id="docker分别拉取grafana和influxdb镜像"><a href="#docker分别拉取grafana和influxdb镜像" class="headerlink" title="docker分别拉取grafana和influxdb镜像"></a>docker分别拉取grafana和influxdb镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull influxdb:1.7.10</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull grafana:6.6.2</span><br></pre></td></tr></table></figure><h3 id="创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信"><a href="#创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信" class="headerlink" title="创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信"></a>创建一个自定义网络，将两个容器加入到这个网络中，那么这两个容器就能通过名字互相通信</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create grafana</span><br></pre></td></tr></table></figure><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=influxdb --network grafana -p 8086:8086 -v   <span class="variable">$&#123;PWD&#125;</span>/influxdb/:/var/liv/influxdb/ influxdb:1.7.10</span><br></pre></td></tr></table></figure><p><code>$&#123;PWD&#125;/influxdb/:/var/liv/influxdb/</code>将容器里/var/liv/influxdb/目录下挂载到宿主机的${PWD}/influxdb/的目录下</p><h3 id="进入influxdb容器内，创建一个数据库"><a href="#进入influxdb容器内，创建一个数据库" class="headerlink" title="进入influxdb容器内，创建一个数据库"></a>进入influxdb容器内，创建一个数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it influxdb influx</span><br><span class="line"><span class="comment"># 进入容器后，创建一个名为jmeter的数据库</span></span><br><span class="line">create database jmeter;</span><br></pre></td></tr></table></figure><h3 id="查看两个容器已经启动"><a href="#查看两个容器已经启动" class="headerlink" title="查看两个容器已经启动"></a>查看两个容器已经启动</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145515315.png"></p><h3 id="登录grafana网站进行配置-默认账号密码为admin-admin"><a href="#登录grafana网站进行配置-默认账号密码为admin-admin" class="headerlink" title="登录grafana网站进行配置(默认账号密码为admin,admin)"></a>登录grafana网站进行配置(默认账号密码为admin,admin)</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104727119.png"></p><h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104813179.png"></p><p><strong><em>jmeter支持两种:graphite和influxdb</em></strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825104934731.png"></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105006045.png"></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105025396.png"></p><p><strong><em>数据同步时间5秒，jmeter隔5秒写入数据到db中，这里设置grafana间隔5秒读取db中的数据。</em></strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105038733.png"></p><h3 id="面板配置"><a href="#面板配置" class="headerlink" title="面板配置"></a>面板配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145131270.png"></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825145204904.png"></p><p><strong><em>导入jmeter的面板地址： <a href="https://grafana.com/grafana/dashboards/5496">https://grafana.com/grafana/dashboards/5496</a></em></strong></p><p><strong><em>也可以下载后导入json文件。</em></strong></p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105457833.png"></p><h3 id="jmeter配置"><a href="#jmeter配置" class="headerlink" title="jmeter配置"></a>jmeter配置</h3><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105610185.png"></p><h3 id="配置完成，发起接口请求即可在grafana实时显示接口相关图表"><a href="#配置完成，发起接口请求即可在grafana实时显示接口相关图表" class="headerlink" title="配置完成，发起接口请求即可在grafana实时显示接口相关图表"></a>配置完成，发起接口请求即可在grafana实时显示接口相关图表</h3><h2 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h2><p>最后，我们来捋一捋，从jmeter开始发起请求到最后在grafana上的数据展示，响应数据是如何进行流转的。</p><h3 id="jmeter"><a href="#jmeter" class="headerlink" title="jmeter"></a>jmeter</h3><p>jmeter使用命令行发起接口请求后，会产生一个**.jtl**的文件，里面记录着每个请求的一些线程数、响应码、响应时间等信息。</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825112742837.png"></p><h3 id="influxdb"><a href="#influxdb" class="headerlink" title="influxdb"></a>influxdb</h3><p>在jmeter中添加了后端监听器，并选择了通过inlufxdb实现后端监听，因此，步骤1中的响应数据，会写入到influxdb的数据库中。</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113234453.png"></p><p>进入influxdb容器内，查看数据</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113841230.png"></p><p>使用<code>select * from jmeter</code>查看数据</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825113901681.png"></p><p>记录了每个请求的详细响应信息。</p><h3 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h3><p>由于我们配置的数据源是influxdb，因此面板展示的所有数据其实都是从influxdb的<strong>jmeter</strong>这个数据库中拿的。</p><p><img src= "/img/loading.gif" data-lazy-src="/posts/59d444a5/image-20200825105006045.png"></p><p><strong>so，整个数据流转，即jmeter产生jtl—&gt;存储到influxdb—&gt;grafana从influxdb拿数据。</strong></p>]]></content>
    
    
    <summary type="html">使用grafana+influxdb搭建一套炫酷的性能监控系统</summary>
    
    
    
    <category term="实战" scheme="http://ancientone.cf/categories/%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="docker" scheme="http://ancientone.cf/tags/docker/"/>
    
    <category term="grafana" scheme="http://ancientone.cf/tags/grafana/"/>
    
    <category term="influxdb" scheme="http://ancientone.cf/tags/influxdb/"/>
    
  </entry>
  
  <entry>
    <title>解决pymongo时区问题</title>
    <link href="http://ancientone.cf/posts/cd8f63bc.html"/>
    <id>http://ancientone.cf/posts/cd8f63bc.html</id>
    <published>2020-06-06T11:25:35.000Z</published>
    <updated>2020-11-23T08:53:07.487Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>最近在做接口自动化框架，其中有涉及到接口返回值与MongoDB中的数据校验，所以用到了pymongo这个库。在使用过程中，踩了一个大坑：当我根据日期去筛选数据的时候，发现接口返回的数据量和mongodb中记录的数据量始终不一致。</p><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>先看三组数据（同一条数据）：</p><p>1.数据库连接工具Navicat中的记录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>: ObjectId(<span class="string">&quot;5f646902ee75270c044f15d2&quot;</span>),</span><br><span class="line">    <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;TypeName&quot;</span>: <span class="string">&quot;运行&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;HappenTime&quot;</span>: ISODate(<span class="string">&quot;2020-03-18T07:55:03.605Z&quot;</span>),</span><br><span class="line">    <span class="attr">&quot;AppName&quot;</span>: <span class="string">&quot;vipservermailG1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;AppFriendlyName&quot;</span>: <span class="string">&quot;邮件服务&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.数据库连接工具MongoDB Compass中的记录</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">&quot;_id&quot;</span>:<span class="string">&quot;5f646902ee75270c044f15d2&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;Version&quot;</span>:<span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">     <span class="attr">&quot;TypeName&quot;</span>:<span class="string">&quot;运行&quot;</span></span><br><span class="line">     <span class="string">&quot;HappenTime&quot;</span>:<span class="number">2020</span><span class="number">-03</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">55</span>:<span class="number">03.605</span>,</span><br><span class="line">     <span class="attr">&quot;AppName&quot;</span>:<span class="string">&quot;vipservermailG1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;AppFriendlyName&quot;</span>:<span class="string">&quot;邮件服务&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.通过pymongo查出的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5f646902ee75270c044f15d2&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;Version&#x27;</span>: <span class="string">&#x27;1.0&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;TypeName&#x27;</span>: <span class="string">&#x27;运行&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;HappenTime&#x27;</span>: datetime.datetime(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">605000</span>), </span><br><span class="line">    <span class="string">&#x27;AppName&#x27;</span>: <span class="string">&#x27;vipservermailG1&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;AppFriendlyName&#x27;</span>: <span class="string">&#x27;邮件服务&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我发现同一条数据，在两个不同的数据库连接工具中日期”HappenTime”居然不一样，这个ISODate是什么鬼？查阅一番资料后才搞明白，原来mongo中的date类型以UTC（Coordinated Universal Time）存储，即格林尼治标准时间，而中国是在东八区，所以系统时间是加了时区的，即UTC+0800时间，<strong>两者正好相差8个小时</strong>。</p><blockquote><p>“2020-03-18T07:55:03.605Z”这种带T带Z的时间即为ISODate，它定义了互联网上日期/时间的偏移量表示。</p><p>同一时刻，不同时区的表示方法：</p><p>UTC时间：2020-03-18T07:55:03.605Z</p><p>CST时间（即东八区北京时间）：2020-03-18T07:55:03.605+08:00</p></blockquote><p>在接口查询数据库时，是以系统时间去查询的，然而从上面第三组数据可以看出，在pymongo去查询数据时，会将ISODate转化为Python的datetime.datetime对象，时间仍然是UTC时间，即没有加时区。所以才会出现两边数据不一致的情况。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在搞懂问题根本原因后，那么解决方法也就非常明确了，在查询数据库时需要加上时区，两边时间保证一致即可。</p><p>pymongo也提供了非常简便地加时区的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"></span><br><span class="line">tzinfo = pytz.timezone(<span class="string">&#x27;Asia/Shanghai&#x27;</span>) <span class="comment"># 时区</span></span><br><span class="line">client = pymongo.MongoClient(</span><br><span class="line">    host=<span class="string">&#x27;1.1.1.1&#x27;</span>, </span><br><span class="line">    port=<span class="number">10</span>, </span><br><span class="line">    username=<span class="string">&#x27;admin&#x27;</span>, </span><br><span class="line">    password=<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    tz_aware=<span class="literal">True</span>, <span class="comment"># 设置为True</span></span><br><span class="line">    tzinfo=tzinfo  <span class="comment"># 传入时区信息</span></span><br><span class="line">)</span><br><span class="line">db = client[<span class="string">&#x27;log&#x27;</span>]</span><br><span class="line">collection = db[<span class="string">&#x27;systemruning&#x27;</span>]</span><br><span class="line">data = collection.find(&#123;<span class="string">&#x27;AppName&#x27;</span>:<span class="string">&#x27;vipservermailG1&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>再次查询时，时间已变为东八区时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;_id&#x27;</span>: ObjectId(<span class="string">&#x27;5f646902ee75270c044f15d2&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;Version&#x27;</span>: <span class="string">&#x27;1.0&#x27;</span>,  </span><br><span class="line">    <span class="string">&#x27;TypeName&#x27;</span>: <span class="string">&#x27;运行&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;HappenTime&#x27;</span>: datetime.datetime(<span class="number">2020</span>, <span class="number">3</span>, <span class="number">18</span>, <span class="number">15</span>, <span class="number">55</span>, <span class="number">3</span>, <span class="number">605000</span>),  <span class="comment"># 加了8小时</span></span><br><span class="line">    <span class="string">&#x27;AppName&#x27;</span>: <span class="string">&#x27;vipservermailG1&#x27;</span>, </span><br><span class="line">    <span class="string">&#x27;AppFriendlyName&#x27;</span>: <span class="string">&#x27;邮件服务&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，问题完美解决，不过既然涉及到了时区相关的问题，就顺便补一下这方面的知识，从源头上彻底了解一下时间的相关概念，以后再遇到类似的问题会游刃有余。</p><h3 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h3><p>GMT（Greenwich Mean Time）， 格林威治平时（也称格林威治时间）。</p><p>它规定太阳每天经过位于英国伦敦郊区的皇家格林威治天文台的时间为中午12点。</p><h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>UTC（Coodinated Universal Time），协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</p><p>UTC 是现在全球通用的时间标准，全球各地都同意将各自的时间进行同步协调。UTC 时间是经过平均太阳时（以格林威治时间GMT为准）、地轴运动修正后的新时标以及以秒为单位的国际原子时所综合精算而成。</p><h3 id="UTC-vs-GMT"><a href="#UTC-vs-GMT" class="headerlink" title="UTC vs GMT"></a>UTC vs GMT</h3><p>GMT是前世界标准时，UTC是现世界标准时。</p><p>UTC 比 GMT更精准，以原子时计时，适应现代社会的精确计时。</p><p>但在不需要精确到秒的情况下，二者可以视为等同。</p><p>每年格林尼治天文台会发调时信息，基于UTC。</p><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时间戳是一个数字，定义为格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。<strong>注意，同一时刻，不同时区获得的时间戳是相同的。</strong>以前很多用来记录时间的字段，在数据库中往往不会存储为Datetime类型，而是直接存储为无符号整形，存放时间戳的值。</p><p>Python获取时间戳的代码为</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">int(time.time())</span><br></pre></td></tr></table></figure><h3 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h3><p>当前时区的本地时间</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import datetime</span><br><span class="line">datetime.datetime.now()</span><br></pre></td></tr></table></figure><p>上面的输出值为</p><blockquote><p>2020-03-20 18:50:03.23743</p></blockquote><h3 id="标准时间"><a href="#标准时间" class="headerlink" title="标准时间"></a>标准时间</h3><p>本地时间只包括当前的时间，不包含任何时区信息。同一时刻，东八区的本地时间比零时区的本地时间快了8个小时。在不同时区之间交换时间数据，除了用纯数字的时间戳，还有一种更方便人类阅读的表示方式：标准时间的偏移量表示方法。</p><p>RFC3339详细定义了互联网上日期/时间的偏移量表示：</p><blockquote><p>2020-03-20T00:00:00.00Z</p></blockquote><p>这个代表了UTC时间的2017年12月08日零时</p><blockquote><p>2020-03-20T00:08:00.00+08:00</p></blockquote><p>这个代表了同一时刻的，东八区北京时间（CST）表示的方法</p><p>上面两个时间的时间戳是等价的。两个的区别，就是在本地时间后面增加了时区信息。Z表示零时区。+08:00表示UTC时间增加8小时。</p><p>这种表示方式容易让人疑惑的点是从标准时间换算UTC时间。以CST转换UTC为例，没有看文档的情况下，根据 +08:00 的结尾，很容易根据直觉在本地时间再加上8小时。正确的计算方法是本地时间减去多增加的8小时。+08:00减去8小时才是UTC时间，-08:00加上8小时才是UTC时间。</p><h3 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h3><p><strong>champyin</strong>：<a href="%5Bhttps://champyin.com/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6%5D(https://link.zhihu.com/?target=https://champyin.com/2020/04/24/%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82GMT%E3%80%81UTC%E3%80%81%E6%97%B6%E5%8C%BA%E5%92%8C%E5%A4%8F%E4%BB%A4%E6%97%B6)">彻底弄懂GMT、UTC、时区和夏令时</a></p><p><strong>柳纯</strong>：<a href="https://ldsink.com/articles/date-and-time-on-the-internet/">互联网上的日期和时间</a></p>]]></content>
    
    
    <summary type="html">解决pymongo时区问题</summary>
    
    
    
    <category term="踩坑" scheme="http://ancientone.cf/categories/%E8%B8%A9%E5%9D%91/"/>
    
    <category term="总结" scheme="http://ancientone.cf/categories/%E8%B8%A9%E5%9D%91/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="mongodb" scheme="http://ancientone.cf/tags/mongodb/"/>
    
    <category term="pymongo" scheme="http://ancientone.cf/tags/pymongo/"/>
    
  </entry>
  
  <entry>
    <title>pytest-fixture使用总结</title>
    <link href="http://ancientone.cf/posts/9752a16f.html"/>
    <id>http://ancientone.cf/posts/9752a16f.html</id>
    <published>2020-05-04T05:55:59.000Z</published>
    <updated>2020-11-23T08:54:53.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言：测试前后的准备清理工作"><a href="#前言：测试前后的准备清理工作" class="headerlink" title="前言：测试前后的准备清理工作"></a>前言：测试前后的准备清理工作</h2><p>通常在测试过程中，都会包括三个步骤：测试前的准备(前置条件)-执行测试-测试后的清理。</p><p>在unittest框架中，通常使用setup/teardown来完成测试的前置和后置操作。</p><p>在pytest框架中，也有类似的方法来完成对应的操作，如使用 setup_method、setup_class、setup_module 来分别完成测试类方法、测试类，以及测试 module 的 setup；；使用 teardown_method、teardown_class、teardown_module 来分别完成测试类方法、测试类，以及测试 module 清理操作。</p><p>但是这种方式存在缺陷。 例如，在同一个测试类中，存在多个测试方法，假设每一个测试方法需要不同的 setup 或者 teardown 函数，此时该怎么办呢？</p><p>又如，这些前后置操作，能放到一个统一模块去管理么？</p><p>答案是肯定的，pytest提供了一种更高级的功能，<strong>fixture装饰器</strong>。</p><p>fixture装饰器可以非常方便的自定义各种前置后置方法供测试用例使用，而且可以通过<strong>conftest.py</strong>文件进行共享，供其他函数、模块、类或者整个项目使用。</p><h2 id="1、fixture语法"><a href="#1、fixture语法" class="headerlink" title="1、fixture语法"></a>1、fixture语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fixture(scope=<span class="string">&quot;function&quot;</span>, params=<span class="literal">None</span>, autouse=<span class="literal">False</span>, ids=<span class="literal">None</span>, name=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>fixture提供了5个参数。</p><h3 id="scope：控制fixture的作用域"><a href="#scope：控制fixture的作用域" class="headerlink" title="scope：控制fixture的作用域"></a>scope：控制fixture的作用域</h3><p>scpoe有4个级别，分别是：</p><p>function:在每一个function或者类方法中都会调用（默认）。</p><p>class:在每一个类中只调用一次。</p><p>module:在每一个.py 文件调用一次。</p><p>session:一个session调用一次，如运行整个项目有100条用例，那么本次用例执行过程中只会调用一次。</p><h3 id="params：一个可选的参数列表"><a href="#params：一个可选的参数列表" class="headerlink" title="params：一个可选的参数列表"></a>params：一个可选的参数列表</h3><p>params 以可选的参数列表形式存在。在测试函数中使用时，可通过 request.param 接收设置的返回值（即 params 列表里的值）。params 中有多少元素，在测试时，引用此 fixture 的函数就会调用几次。</p><h3 id="autouse：是否自动执行设置的-fixtures"><a href="#autouse：是否自动执行设置的-fixtures" class="headerlink" title="autouse：是否自动执行设置的 fixtures"></a>autouse：是否自动执行设置的 fixtures</h3><p>当 autouse 为 True 时，测试函数即使不调用 fixture 装饰器，定义的 fixture 函数也会被执行。</p><h3 id="ids：指定每个字符串-id"><a href="#ids：指定每个字符串-id" class="headerlink" title="ids：指定每个字符串 id"></a>ids：指定每个字符串 id</h3><p>当有多个 params 时，针对每一个 param，可以指定 id，这个 id 将变为测试用例名字的一部分。如果没有提供 id，则 id 将自动生成。</p><h3 id="name：fixture-的名称"><a href="#name：fixture-的名称" class="headerlink" title="name：fixture 的名称"></a>name：fixture 的名称</h3><p>name 是 fixtures 的名称， 它默认是你装饰的那个 fixture 函数的名称。可以通过 name 参数来更改这个 fixture 名称，更改后，如果这个 fixture 被调用，则使用更改后的名称即可。</p><h2 id="2、fixture-用法"><a href="#2、fixture-用法" class="headerlink" title="2、fixture 用法"></a>2、fixture 用法</h2><h3 id="通过函数名直接使用"><a href="#通过函数名直接使用" class="headerlink" title="通过函数名直接使用"></a>通过函数名直接使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将fixture的名字通过参数直接传入测试方法即可。运行用例后，<code>demo()</code>方法会先于<code>test_demo()</code>执行。</p><h3 id="通过usefixtures装饰器使用"><a href="#通过usefixtures装饰器使用" class="headerlink" title="通过usefixtures装饰器使用"></a>通过usefixtures装饰器使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.usefixtures(&#x27;demo&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.usefixtures(&#x27;demo&#x27;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo_1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo_2</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这样写的话，<strong>fixture无法返回参数</strong>。</p><h3 id="多参数使用"><a href="#多参数使用" class="headerlink" title="多参数使用"></a>多参数使用</h3><p>由于fixture提供了<code>paramas</code>参数，因此fixture也可以实现参数化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(params=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture：<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">demo</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PASSED                                             [ 33%]test</span><br><span class="line">调用fixture：b</span><br><span class="line">PASSED                                             [ 66%]test</span><br><span class="line">调用fixture：c</span><br><span class="line">PASSED                                             [100%]test</span><br></pre></td></tr></table></figure><p>可以看到，将会生成3条用例。</p><h3 id="autouse-参数隐式使用"><a href="#autouse-参数隐式使用" class="headerlink" title="autouse 参数隐式使用"></a>autouse 参数隐式使用</h3><p>以上方式实现了 fixtures 和测试函数的松耦合，但是仍然存在问题：每个测试函数都需要显式声明要用哪个 fixtures。</p><p>基于此，pytest 提供了<strong>autouse 参数</strong>，允许我们在不调用 fixture 装饰器的情况下使用定义的fixture。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(autouse=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span>():</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fixture&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;test&#x27;</span>)</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">demo.py::test_demo 调用fixture</span><br><span class="line">PASSED                                                [100%]测试</span><br></pre></td></tr></table></figure><h3 id="多-fixture-笛卡尔积使用"><a href="#多-fixture-笛卡尔积使用" class="headerlink" title="多 fixture 笛卡尔积使用"></a>多 fixture 笛卡尔积使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(params=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix1</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fix1:<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(params=[1, 2])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix2</span>(<span class="params">request</span>):</span></span><br><span class="line">    print(<span class="string">f&#x27;调用fix2:<span class="subst">&#123;request.param&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix1, fix2</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>将会生成3*2=6条用例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">调用fix1:a</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 16%]-----我是分割线------</span><br><span class="line">调用fix1:a</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [ 33%]-----我是分割线------</span><br><span class="line">调用fix1:b</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 50%]-----我是分割线------</span><br><span class="line">调用fix1:b</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [ 66%]-----我是分割线------</span><br><span class="line">调用fix1:c</span><br><span class="line">调用fix2:1</span><br><span class="line">PASSED                                           [ 83%]-----我是分割线------</span><br><span class="line">调用fix1:c</span><br><span class="line">调用fix2:2</span><br><span class="line">PASSED                                           [100%]-----我是分割线------</span><br></pre></td></tr></table></figure><h3 id="fixture间嵌套使用"><a href="#fixture间嵌套使用" class="headerlink" title="fixture间嵌套使用"></a>fixture间嵌套使用</h3><p>不同的fixture间也可以嵌套使用，将<code>fix1</code>作为参数传入<code>fix2</code>中，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix1</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;调用fix1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix2</span>(<span class="params">fix1</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;调用fix2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix2</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo.py::test_demo 调用fix1</span><br><span class="line">调用fix2</span><br><span class="line">PASSED                                                [100%]-----我是分割线------</span><br></pre></td></tr></table></figure><p>可以看到，当调用<code>fix2</code>时，会先调用fix1。</p><h3 id="使用-conftest-py-来共享-fixture"><a href="#使用-conftest-py-来共享-fixture" class="headerlink" title="使用 conftest.py 来共享 fixture"></a>使用 conftest.py 来共享 fixture</h3><p>日常工作测试中，我们常常需要在全局范围内使用同一个测试前置操作。例如，测试开始时首先进行登录操作，接着连接数据库。</p><p>这种情况下，我们就需要使用 <strong>conftest.py</strong>。在 conftest.py 中定义的 fixture 不需要进行 import，pytest 会自动查找使用。 pytest 查找 fixture 的顺序是首先查找测试类（Class），接着查找测试模块（Module），然后是 conftest.py 文件，最后是内置或者第三方插件。</p><h3 id="通过yield唤醒teardown"><a href="#通过yield唤醒teardown" class="headerlink" title="通过yield唤醒teardown"></a>通过yield唤醒teardown</h3><p>前面fixture已经帮我们实现了前置操作，那么后置如何实现呢？非常简单，通过关键字<strong>yield</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;我是前置条件&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    print(<span class="string">&#x27;我是后置条件&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;-----我是分割线------&#x27;</span>)</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo.py::test_demo 我是前置条件</span><br><span class="line">PASSED                                                [100%]-----我是分割线------</span><br><span class="line">我是后置条件</span><br></pre></td></tr></table></figure><p>通过yield，会讲该函数变为生成器，这里具体原理先不展开，简单来说，<strong>yield之前的前置条件，yield之后的为后置条件。</strong></p><h3 id="有返回值的fixture"><a href="#有返回值的fixture" class="headerlink" title="有返回值的fixture"></a>有返回值的fixture</h3><p>大部分情况下，我都会使用fixture来返回一些值来供测试用例使用，如登录的cookie、token、数据库的连接对象等，那么fixture的返回值又是如何传递给用例的呢？如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    <span class="comment"># 接收fix值传递给了变量x</span></span><br><span class="line">    x= fix</span><br><span class="line">    print(<span class="string">f&#x27;这是我接收到fix的变量：<span class="subst">&#123;x&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当然，也可以是多个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix</span>():</span></span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">    c = <span class="number">3</span> + <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> a,b,c</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">fix</span>):</span></span><br><span class="line">    <span class="comment"># 接收fix值传递给了变量x,y,z</span></span><br><span class="line">    <span class="comment"># 如果只用一个变量接收，类型将会是元组</span></span><br><span class="line">    x,y,z = fix</span><br><span class="line">    print(<span class="string">f&#x27;这是我接收到fix的变量：<span class="subst">&#123;x&#125;</span><span class="subst">&#123;y&#125;</span><span class="subst">&#123;z&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同理，<strong>yield</strong>也能返回值。</p><h3 id="pytest-mark-parametrize-和-pytest-fixture-结合使用"><a href="#pytest-mark-parametrize-和-pytest-fixture-结合使用" class="headerlink" title="pytest.mark.parametrize 和 pytest.fixture 结合使用"></a>pytest.mark.parametrize 和 pytest.fixture 结合使用</h3><p>现在有一个问题，如果fixture是做了参数化的，如何在用例中动态地给它传入参数呢？</p><p>在我日常工作中，会有这么一种场景：通常我会把数据库连接放到fixture中，但是不同case中用到的数据库可能不是同一个，这就导致我会根据不同的数据库配置信息，实例多个db连接对象，那么我该如何把不同的数据库配置信息，在用例层传入给fixture呢？总不可能每个数据库都创建一个fixture吧？来看看用fixture结合parametrize是如何优雅地实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope=&#x27;class&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_db</span>(<span class="params">request</span>):</span></span><br><span class="line">    db = HandleMysql(request.param)</span><br><span class="line">    <span class="keyword">yield</span> db</span><br><span class="line">    db.close()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span>:</span></span><br><span class="line">    <span class="comment"># db1,db2,db3是伪代码，表示数据库不同的连接配置信息</span></span><br><span class="line"><span class="meta">    @pytest.mark.parametrize(&#x27;connect_db&#x27;, [db_conf], indirect=True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_demo</span>(<span class="params">self,connect_db</span>):</span></span><br><span class="line">        <span class="comment"># 接收fix值传递给了变量x</span></span><br><span class="line">        db = connect_db</span><br><span class="line">        print(<span class="string">f&#x27;这是我的数据库连接对象：<span class="subst">&#123;connect_db&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><p>首先，fixture做了参数化，那么就需要在fixture中接受变量，传入<strong>request</strong>这个内置fixture，然后传入的变量，通过request的<strong>param</strong>接收，这是需要再fixture内部做的操作。</p><p>然后，在用例层的**@pytest.mark.parametrize**中，将配置信息变量<code>db_conf</code>传入到<code>connect_db</code>这个fixture中，需要注意的是，这里必须设置参数<code>indirect=True</code>。</p><blockquote><p>当indirect为True的时候，变量为固件函数名称的，执行的时候会将变量（此例中即为connect_db）当做函数来执行。</p><p>当indirect为false的时候，变量为固件函数名称的，执行的时候会将变量当做一个参数来执行。</p></blockquote><p>ok，日常项目中，关于fixture的使用就如上所述了。</p>]]></content>
    
    
    <summary type="html">前言:关于fixture</summary>
    
    
    
    <category term="总结" scheme="http://ancientone.cf/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="pytest" scheme="http://ancientone.cf/tags/pytest/"/>
    
  </entry>
  
</feed>
